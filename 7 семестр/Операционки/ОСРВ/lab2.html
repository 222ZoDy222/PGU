<HTML>
<HEAD>
<TITLE> Методические указания по дисциплине "Системы реального времени"</TITLE>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<STYLE> 
@import URL("stil.css"); 
</STYLE> 
</HEAD>
<BODY background="images/whttxtr2.jpg">
<A name=omu></A>
<P>Даны указания по выполнению лабораторных работ и задания к ним. Лабораторные работы предназначены для изучения прикладного программного интерфейса Win32 API операционной системы Windows и для постановки лабораторного практикума по дисциплине «Системы реального времени». </P>
<H3><CENTER>Общие методические указания</CENTER></H3>
<P>Работы выполняются в среде семейства операционных систем Windows NT-based. 
<BR>&nbsp;&nbsp; &nbsp;Написание программ следует выполнять в среде программирования Visual C++ 6.0. Отладку осуществлять встроенным отладчиком среды программирования. 
<BR>
&nbsp;&nbsp; &nbsp;При разработке программ основное внимание следует уделять не усложнению функций пользовательского интерфейса, а продуманной структурной организации внутренней программной логики.</P>
<A name=treb></A>
<H3><CENTER>Требования к оформлению работ</CENTER></H3>
<P>По каждой лабораторной работе необходимо составить отчет, который должен содержать:
<UL type=circle > <LI> титульный лист; <LI> название и цель работы; <LI>лабораторное задание;<LI>описание данных и при необходимости описание структуры программы;<LI>текст программы;<LI>результаты выполнения программы;<LI>выводы по результатам выполнения работы.</UL></P>
<BR><BR>
<BR><BR>
<A name=lab2></A>
<H3><CENTER><U>Лабораторная работа №2 </U><BR>"Передача данных с использованием почтовых ящиков и ждущих таймеров,перехват и фильтрация информации с использованием системных перехватчиков"</CENTER></H3>
<P>
<A href="#aim"><B>Цели работы</a><BR>
&nbsp;&nbsp; &nbsp;<A href="#metod">Методические указания</a><BR>
&nbsp;&nbsp; &nbsp;<A href="#task">Задания</a><BR>
&nbsp;&nbsp; &nbsp;<A href="#control">Контрольные вопросы</a><BR>
&nbsp;&nbsp; &nbsp;<A href="#dop">Справочники по WIN32 API</a><BR>
&nbsp;&nbsp; &nbsp;<A href="#pri">Примеры на Visual C++ с использованием WIN32 API</a><BR>
</B>
<A name=aim></A>
<P><U>Цели работы</U> - Изучение построения клиент-серверного взаимодействия процессов с использованием почтовых ящиков. Изучение особенностей работы нитей при использовании ждущих таймеров.Изучить методику установки и снятия системных перехватчиков для эффективной реакции программы на действия пользователя.изучение методов и средств порождения процессов и нитей, изучение способов синхронизации процессов и нитей через ожидание окончания их выполнения.</P>
<A name=metod></A>
<P><U>Методические указания</U><BR><BR></P>
<H2>Список используемых системных вызовов</H2>
<H2><BR>CreateMailslot<BR> CreateFile<BR> GetMailslotInfo<BR> SetMailslotInfo<BR> ReadFile<BR> ReadFileEx<BR> WriteFile<BR> WriteFileEx<BR> CreateWaitableTimer<BR> OpenWaitableTimer<BR> SetWaitableTimer<BR> 
CancelWaitableTimer<BR> 
SleepEx<BR> WaitForSingleObjectEx<BR> WaitForMultipleObjectsEx<BR>SetWindowsHookEx<BR> UnhookWindowsHookEx<BR> CallNextHookEx<BR>
</H2>
<p><BR>
</p>
<p>Почтовые ящики позволяют процессам обмениваться данными в пределах локальной сети Microsoft. На стороне клиента используется функция работы с файлами CreateFile. Для записи и чтения из почтового ящика используются функции ReadFile и WriteFile соответственно. (Для работы почтового ящика совместно с ждущим таймером следует использовать функции ReadFileEx и WriteFileEx). Для получения информации о наличии данных в почтовом ящике на стороне сервера используется функция GetMailslotInfo. 
  Ждущие таймеры используются для выполнения определенных действий в заданное время или через заданный интервал времени. Ждущий таймер создается с помощью функции CreateWaitableTimer. Ожидание срабатывания таймера можно производить с помощью WaitFor-функций. Другой способ – задать специальную callback-функцию, которая выполнится сразу после перехода таймера в сигнальный режим. При этом нить должна находится в особом состоянии, называемом «тревожным» (alertable). Нить находится в этом состоянии при выполнении функций ожидания с суффиксом Ex: ReadFileEx, WriteFileEx, SleepEx, WaitForSingleObjectEx, WaitForMultipleObjectsEx, и других.
  Ждущие таймеры, как и мьютексы, бывают с ручным сбросом и синхронизирующие. Синхронизирующие таймеры используются для временной синхронизации процессов и нитей или для однократного вызова callback-функции. Ждущие таймеры используются для периодического вызова callback-функции.
  С помощью ждущих таймеров можно легко программировать максимальное время ожидания поступления данных в почтовый ящик.Для перехвата оконных сообщений, системных сообщений, нажатий на клавиатуру, событий изменения положения и размера окна и т. п. используются системные перехватчики. Системный перехватчик можно установить на выбранную нить или на все нити текущего рабочего стола.
  Для установки системного перехватчика используется функция SetWindowsHookEx. Параметр idHook используется для выбора типа перехватчика. Параметр dwThreadId задает идентификатор нити, на которую устанавливается перехватчик. Если он равен нулю, то перехватчик устанавливается на все нити. Функция перехватчика (параметр lpfn) в этом случае должна находиться в DLL, а параметр hMod должен содержать дескриптор библиотеки. Функция возвращает дескриптор на объект перехватчика.
  Внутри перехватчика должна вызываться функция CallNextHookEx для обеспечения цепочки вызова перехватчиков. Вызов этой функции не обязателен, но настоятельно рекомендован. Если не вызывать эту функцию, то все перехватчики, установленные ранее, не получат управление.
  Для отключения перехватчика используется функция UnhookWindowsHookEx. Параметр hhk должен содержать закрываемый дескриптор системного перехватчика. Для более подробного ознакомления с функциями и переменными перехватчика нажмите <A href="HOOKS.html#hook">здесь</a>.<BR>
  Подробнее о функциях используемых в этой работе смотрите в предлагаемых к этой работе <A href="#dop">справочниках</a> по Win32 API.</p>
<p><BR>
	<A href="lab.html#omu">Общие методические указания; </a>
  <BR>
  <A name=task></A>
</p>
<P><U>Задания</U><BR><BR></P>
<I><OL type=1 start=1 >
<B><LI>Разработать программу периодической проверки свободного места на жестком диске (функция GetDiskFreeSpace) и сбора данной информации на едином сервере с использованием почтового ящика.
<LI>Разработать программу получения статистики по использованию памяти процессом (функция GetProcessMemoryInfo) и сбора данной информации на едином сервере с использованием почтового ящика.
<LI>Разработать программу передачи сообщений между двумя пользователями с использованием почтовых ящиков.
<LI>Разработать программу автоматического уведомления пользователя о завершении текущего занятия.
<LI>Разработать программу-будильник (функция MessageBeep). Установка будильника должна осуществляться с другого компьютера с использованием почтового ящика.
<LI>Разработать программу измерения загрузки центрального процессора компьютера в процентном отношении для параллельно выполняющихся нитей с помощью ждущего таймера и функции Sleep.
<LI>Разработать программу, позволяющую исследовать структуру каталога “c:\” на удаленном компьютере с помощью функций FindFirstFile, FindNextFile.
<LI>Разработать программу вычисления разницы в значениях текущего времени на двух компьютерах с помощью функции GetLocalTime.
<LI>Разработать программу передачи файла по запросу с одного компьютера на другой.
<LI>Разработать программу, передающую на сервер данные о текущем пользователе системы (функция GetUserName).
<LI>Разработать программу, передающую на сервер данные о версии операционной системы (функция GetVersionEx).
<LI>Разработать программу, передающую на сервер данные о каталоге операционной системы и каталоге временных файлов пользователя (функции GetWindowsDirectory, GetTempPath).
<LI>Разработать программу, выводящую на экран текстовое сообщение при нажатии пользователем комбинации клавиш Alt+S.
<LI>Разработать программу, выводящую на экран текстовое сообщение при приведении курсора мыши в левый верхний угол экрана.
<LI>Разработать программу, выводящую на экран текстовое сообщение при минимизации любого окна на рабочем столе.
<LI>Разработать программу, выводящую на экран текстовое сообщение при активизации любого окна, содержащего в имени слово «СПО».
<LI>Разработать программу, выводящую на экран текстовое сообщение при закрытии любого окна верхнего уровня.
<LI>Разработать программу, выводящую на экран текстовое сообщение при вводе пользователем с клавиатуры слова «СПО».
<LI>Разработать программу, выводящую на экран текстовое сообщение при изменении размеров или перемещении любого окна.
<LI>Разработать программу, выводящую на экран текстовое сообщение при нажатии пользователем левой кнопки мыши в правом нижнем углу окна.
<LI>Разработать программу, выводящую на экран текстовое сообщение при нажатии пользователем левой кнопки мыши в меню окна.
<LI>Разработать программу, выводящую на экран текстовое сообщение при нажатии пользователем левой кнопки мыши в заголовке окна.
<LI>Разработать программу, выводящую на экран текстовое сообщение при отсутствии движений мышью в течение 1 минуты.
<LI>Разработать программу, выводящую на экран текстовое сообщение при запуске нового оконного приложения.
</B></OL></I>

<BR><BR>
<A name=control></A><P><U>Контрольные вопросы</U><BR><BR></P>
<I><OL type=1 start=1 ><B>
<LI>Чем ждущий таймер с ручным сбросом отличается от синхронизирующего ждущего таймера?
<LI>Как ждущий таймер можно использовать для пробуждения операционной системы?
<LI>Что означает «тревожное» состояние нити? Какие функции переводят нить в «тревожное» состояние?
<LI>Какова область действия почтовых ящиков?
<LI>Могут ли существовать несколько почтовых ящиков с одинаковыми именами?
<LI>Как с использованием системных перехватчиков запрограммировать реакцию программы на нажатие «горячего» сочетания клавиш?
<LI>Как с использованием системных перехватчиков запрограммировать реакцию программы на нахождение курсора мыши в заранее заданной области?
<LI>Как с использованием системных перехватчиков запрограммировать всплывающие подсказки пользователю?
</B>
</OL></I>
<BR>
<A name=dop></A>
<P><U>Справочники по WIN32 API</U><BR></P>
<H2><A href="Windows WIN32 API EN.exe">Полный справочник по функциям Win32 API(анг)</a></H2>
<H2><A href="Windows WIN32 API RU.exe">Русская справка по Windows API</a></H2>
<BR><BR></P>
<A name=pri></A>
<P><U>Примеры на Visual C++ 6.0 с использованием WIN32 API </U><BR></P><BR>
<H3>Прерывания клавиатуры</H3>
<h2>Для Visual C++ 6.0 все действия с клавиатуры можно перехватить в функции OnKeyDown, это выглядит приме&#1088;но следующим образом: <BR>
  <BR>
  void CTempProjectDlg::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags) <br>
  {<br>
// &#1050;&#1072;&#1082;&#1080;&#1077; &#1090;&#1086; &#1076;&#1077;&#1081;&#1089;&#1090;&#1074;&#1080;&#1103;, &#1082;&#1086;&#1076; &#1082;&#1083;&#1072;&#1074;&#1080;&#1096;&#1080; &#1085;&#1072;&#1093;&#1086;&#1076;&#1080;&#1090;&#1089;&#1103; &#1074; &#1087;&#1077;&#1088;&#1077;&#1084;&#1077;&#1085;&#1085;&#1086;&#1081; nChar <br>
<br>
CDialog::OnKeyDown(nChar, nRepCnt, nFlags);//&#1087;&#1077;&#1088;&#1077;&#1076;&#1072;&#1105;&#1084; &#1089;&#1086;&#1086;&#1073;&#1097;&#1077;&#1085;&#1080;&#1077; &#1076;&#1072;&#1083;&#1100;&#1096;&#1077; &#1087;&#1086; &#1094;&#1077;&#1087;&#1086;&#1095;&#1082;&#1077;<br>
}</h2>
<h2>Но это нам не подойдет, если мы хотим написать обработчик для системных ключей клавиатуры например TAB или RETURN(Enter) необходимо использовать функцию OnSysKeyDown, &#1072; &#1083;&#1091;&#1095;&#1096;&#1077; более универсальный способ фильтр событий ProcessMessageFilter,  &#1074;&#1099;&#1075;&#1083;&#1103;&#1076;&#1077;&#1090;&#1100; &#1101;&#1090;&#1086; &#1073;&#1091;&#1076;&#1077;&#1090; примерно так:</h2>
<h2>BOOL CTempProjectApp::ProcessMessageFilter(int code, LPMSG lpMsg) //&#1060;&#1080;&#1083;&#1100;&#1090;&#1088; &#1074;&#1077;&#1096;&#1072;&#1077;&#1090;&#1089;&#1103; &#1085;&#1072; &#1087;&#1088;&#1086;&#1094;&#1077;&#1089;&#1089;<br>
  {<br>
// TODO: Add your specialized code here and/or call the base class<br>
<br>
return CWinApp::ProcessMessageFilter(code, lpMsg); //Передаются на дальнейшую обработку<br>
}<BR>
Все события и сообщения  в приложениях созданных с помощью библиотеки Visaul C++ 6.0 можно перехватить здесь.
<h2 class=char>
 !!!Используя стандартные классы и функции библиотеки Visaul, вы тем самым привязываете себя к одной платформе.:-( 
</h2>
</h2>
<H3>Список процессов.</H3>
<H2>
Использовать функцию CrealeToolhelp32Snapshol для снятия слепка системы, и функции Process32Firsl и Process32Nexl для получения процессов из этого слепка.<BR>
<H2>
void CLab3SRTDlg::OnTimer(UINT nIDEvent) <BR>
{<BR>
	// TODO: Add your message handler code here and/or call default<BR>
	m_ListOut.ResetContent();<BR>
	HANDLE hProcessSnap;<BR>
	PROCESSENTRY32 pe32;<BR>
	pe32.dwSize = sizeof( PROCESSENTRY32 );<BR>
	hProcessSnap = CreateToolhelp32Snapshot( TH32CS_SNAPPROCESS, 0 );<BR>

	if (Process32First(hProcessSnap,&pe32))<BR>
	{

			m_ListOut.AddString(pe32.szExeFile);<BR>
		while (Process32Next(hProcessSnap,&pe32))<BR>
			m_ListOut.AddString(pe32.szExeFile);<BR>
	}
else <BR>
	AfxMessageBox("Ошибка при получении информации");<BR>
	CloseHandle(hProcessSnap); ////Хендл закрывать обязательно!<BR>
	CDialog::OnTimer(nIDEvent);<BR>
}<BR>
<BR></H2>
<H3>Получение информации о текущем состоянии физической и виртуальной памяти.</H3>
</H2>
<h2>BOOL CInfoCollector::GetMemoryInfo(CString&amp; szCpuInfo)<br>
  {<br>
 	MEMORYSTATUS memstat;<br>
  	CString szTemp;<br>
	GlobalMemoryStatus(&amp;memstat);<br>
	szCpuInfo.Format(_T(&quot;Total physical memory : %u Kb\r\n&quot;),memstat.dwTotalPhys/1024);<br>
	szTemp.Format(_T(&quot;Avail physical memory : %u Kb\r\n&quot;),memstat.dwAvailPhys/1024);<br>
	szCpuInfo += szTemp;<br>
	szTemp.Format(_T(&quot;Total virtual memory : %u Kb\r\n&quot;),memstat.dwTotalPageFile /1024);<br>
	szCpuInfo += szTemp;<br>
	szTemp.Format(_T(&quot;Avail virtual memory : %u Kb&quot;),memstat.dwAvailPageFile/1024);<br>
	szCpuInfo += szTemp;<br>
 	return TRUE;<br>
 	}<BR>
</h2>
<H3>Как получить папки Windows, System, а также получить, установить текущий каталог.</H3>
<H2>void CTempProjectDlg::OnButton1() <br>
  {<br>
// TODO: Add your control notification handler code here<br>
int nSize;<br>
CHAR buff[1024];<br>
CString tmp;<br>
nSize=sizeof(buff);<br>
GetCurrentDirectory(nSize, buff); // &#1055;&#1086;&#1083;&#1091;&#1095;&#1072;&#1077;&#1084; &#1087;&#1091;&#1090;&#1100; &#1082; &#1090;&#1077;&#1082;&#1091;&#1097;&#1080;&#1084;&#1091; &#1082;&#1072;&#1090;&#1072;&#1083;&#1086;&#1075;&#1091;<br>
tmp=buff;<br>
m_ListOut.AddString(tmp);<br>
GetWindowsDirectory(buff, nSize); // &#1055;&#1086;&#1083;&#1091;&#1095;&#1072;&#1077;&#1084; &#1087;&#1091;&#1090;&#1100; &#1082; &#1082;&#1072;&#1090;&#1072;&#1083;&#1086;&#1075;&#1091; Windows<br>
tmp=buff;<br>
m_ListOut.AddString(tmp);<br>
GetSystemDirectory(buff, nSize); // &#1055;&#1086;&#1083;&#1091;&#1095;&#1072;&#1077;&#1084; &#1087;&#1091;&#1090;&#1100; &#1082; &#1082;&#1072;&#1090;&#1072;&#1083;&#1086;&#1075;&#1091; System<br>
tmp=buff;<br>
m_ListOut.AddString(tmp);<br>
SetCurrentDirectory(&quot;c:\temp&quot;); //&#1059;&#1089;&#1090;&#1072;&#1085;&#1072;&#1074;&#1083;&#1080;&#1074;&#1072;&#1077;&#1084; &#1089;&#1086;&#1073;&#1089;&#1090;&#1074;&#1077;&#1085;&#1085;&#1099;&#1081; &#1090;&#1077;&#1082;&#1091;&#1097;&#1080;&#1081; &#1082;&#1072;&#1090;&#1072;&#1083;&#1086;&#1075;<br>
GetCurrentDirectory(nSize, buff); // &#1055;&#1086;&#1083;&#1091;&#1095;&#1072;&#1077;&#1084; &#1087;&#1091;&#1090;&#1100; &#1082; &#1082;&#1072;&#1090;&#1072;&#1083;&#1086;&#1075;&#1091; <br>
tmp=buff;<br>
m_ListOut.AddString(tmp); <br>
}<BR>
<BR>
</H2>

</BODY>
</HTML> 