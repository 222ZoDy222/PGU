<HTML>
<HEAD>
<TITLE> Методические указания по дисциплине "Системы реального времени"</TITLE>
<STYLE> 
@import URL("stil.css"); 
</STYLE> 
</HEAD>
<BODY background="images/whttxtr2.jpg">
<A name=omu></A>
<P>Даны указания по выполнению лабораторных работ и задания к ним. Лабораторные работы предназначены для изучения прикладного программного интерфейса Win32 API операционной системы Windows и для постановки лабораторного практикума по дисциплине «Системы реального времени». </P>
<H3><CENTER>Общие методические указания</CENTER></H3>
<P>Работы выполняются в среде семейства операционных систем Windows NT-based. 
<BR>&nbsp;&nbsp; &nbsp;Написание программ следует выполнять в среде программирования Visual C++ 6.0. Отладку осуществлять встроенным отладчиком среды программирования. 
<BR>&nbsp;&nbsp; &nbsp;При разработке программ основное внимание следует уделять не усложнению функций пользовательского интерфейса, а продуманной структурной организации внутренней программной логики.</P>
<A name=treb></A>
<H3><CENTER>Требования к оформлению работ</CENTER></H3>
<P>По каждой лабораторной работе необходимо составить отчет, который должен содержать:
<UL type=circle > <LI> титульный лист; <LI> название и цель работы; <LI>лабораторное задание;<LI>описание данных и при необходимости описание структуры программы;<LI>текст программы;<LI>результаты выполнения программы;<LI>выводы по результатам выполнения работы.</UL></P>
<BR><BR>
<A name=lab1></A>
<H3><CENTER><U>Лабораторная работа №1

 </U><BR>"Порождение и завершение процессов и потоков"</CENTER></H3>
<P>


<A href="#aim"><B>Цель работы</a><BR>
&nbsp;&nbsp; &nbsp;<A href="#metod">Методические указания</a><BR>
&nbsp;&nbsp; &nbsp;<A href="#task">Задания</a><BR>
&nbsp;&nbsp; &nbsp;<A href="#control">Контрольные вопросы</B></a></P>
<A name=aim></A>
<P><U>Цель работы</U> - изучение методов и средств порождения процессов и нитей, изучение способов синхронизации процессов и нитей через ожидание окончания их выполнения.</P>
<A name=metod></A>
<P><U>Методические указания</U><BR><BR>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<A href="#metod_win">Многозадачность в Windows</a><BR>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<A href="#metod_workproc">Запуск процесса</a><BR>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<A href="#metod_destroyproc">Завершение процесса</a><BR>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<A href="#metod_worktr">Создание рабочего потока</a><BR>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<A href="#metod_inter">Создание интерфейсных потоков</a><BR>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<A href="#metod_worktrapi">Создание потока WinApi</a><BR>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<A href="#metod_destroytrapi">Завершение потока WinApi</a><BR>
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<A href="#metod_example">Примеры использования</a><BR><BR><BR>


&nbsp;&nbsp; &nbsp;<A name=metod_win></A><H3><CENTER>Многозадачность в Windows</CENTER></H3>
<P>
&nbsp;&nbsp; &nbspГрафическая оболочка Windows разрабатывалась как среда с кооперативной многозадачностью (cooperative multiasking) без разделения времени. Это означало, что некоторая функция, получив управление, не отдавала его до тех пор, пока не завершала свою работу, или ее работа не прерывалась извне. Если функция осуществляет достаточно сложные вычисления над большим объемом данных, подобный подход может привести к практическому зависанию системы. Эта особенность сохранилась и после превращения графической оболочки в операционную систему. Выходом из этой ситуации является использование потоков.
<BR>&nbsp;&nbsp; &nbsp Начиная с Windows'95 и Windows NT введно понятие многозадачности. В этой системе реализована истинная многозадачность, т. е. каждой программе системой выделяется квант времени, в течение которого программа обрабатывает поступившие в ее адрес сообщения. Вне зависимости от состояния программы СИСТЕМА забирает управление у программы и передает его другой программе. Если программа зависла, то система от этого не пострадает. Управление в любом случае будет передано другой программе. Кроме этого, в Windows'95 и Windows NT введено понятие процесса. Грубо говоря, процесс - это совокупность выполняющейся программы и выделенных ей системных ресурсов. Случай, при котором программа может вырваться из рамок своего процесса и повредить еще чьи-то ресурсы, практически не возможен.
<BR>&nbsp;&nbsp; &nbspРассуждаем дальше. Раз программа получает управление на время, то почему бы этой программе не распараллелить свою работу и не запустить несколько одновременно выполняющихся программ под своим управлением? В Win32 эти программы называются потоками.
Таким образом, в системе Windows реализованы два типа многозадачности - процессная и потоковая. Рассмотрим оба типа многозадачности.
<BR>&nbsp;&nbsp; &nbspПотоки (threads) обладают свойством вытесняющей многозадачности (preemptive multitasking). Это означает, что каждому потоку в соответствии с его приоритетом выделяется квант времени для его выполнения. По истечении данного кванта времени выполнение процесса прерывается и вызывается процедура распределения квантов времени, которая при отсутствии других,более приоритетных претендентов, может опять выделить квант времени тому же потоку.<BR>
&nbsp;&nbsp; &nbspПриложение Win32 состоит из одного или более процессов. Под процессом (process) можно понимать некоторую исполняемую программу. В соответствии с другим определением под процессом понимают исполняемое приложение. Например, при двойном щелчке на значке Блокнот запускается процесс, в котором исполняется приложение Блокнот. В одном процессе могут быть запущены один или несколько потоков. Поток представляет собой основную программную единицу, которой операционная система предоставляет процессорное время. В потоке может выполняться любой программный код, являющийся составной частью данного процесса, включая программный код, который в настоящее время выполняется другим процессом. Под потоком можно понимать ветвь исполнения процесса. При запуске приложения Блокнот операционная система создает процесс и запускает на исполнение основной поток данного процесса. При завершении работы данного потока завершается и процесс. Основной поток приложения запускается операционной системой и передается ей в качестве адреса функции, запускающей данный поток. Обычно это адрес функции main или WinMain. Пользователь может создавать в приложении дополнительные потоки, если в этом возникает необходимость. Например, требуется выделить фоновые процессы, выполнение которых необходимо для правильной работы приложения, но так, чтобы пользователь не дожидался их окончания для продолжения работы с приложением.<BR>
&nbsp;&nbsp; &nbspВсе потоки в приложениях, использующих библиотеку MFC, используют объекты класса cwinThread или производных от него классов. В большинстве случаев пользователю нет необходимости самому создавать эти объекты. Достаточно вызвать функцию AfxBeginThread, которая сама создаст необходимый объект и запустит поток на исполнение. Библиотека MFC позволяет работать с двумя видами потоков: интерфейсными и рабочими. Интерфейсные потоки обычно используются для обработки команд и сообщений пользователя. Рабочие потоки — для выполнения задач, не требующих вмешательства пользователя, например, для фоновых вычислений. API Win32 не различает эти виды потоков. Ему надо только сообщить начальный адрес потока, по которому следует произвести его запуск на исполнение. Интерфейсный поток содержит собственный цикл обработки сообщений, позволяющий ему обрабатывать сообщения и команды пользователя. Примером кладса интерфейсного потока может служить класс cwinApp, производный от класса cwinThread и осуществляющий обработку событий и сообщений, поступающих в приложение. Особое внимание следует уделить ситуации, когда несколько потоков имеют доступ к одному и тому же объекту. Для этого необходимо произвести их синхронизацию. Методы синхронизации будут описаны в лабораторной работе №3. При написании и отладке приложений, в которых используется несколько потоков, необходимо убедиться, что ни к одному из имеющихся объектов приложения не может быть осуществлен одновременный доступ из нескольких потоков.
&nbsp;&nbsp; &nbsp;<BR>
</P>




&nbsp;&nbsp; &nbsp;<A name=metod_workproc></A><H3><CENTER>ЗАПУСК ПРОЦЕССА</CENTER></H3>
&nbsp;&nbsp; &nbsp;В Win32 процесс определяют как копию (экземпляр) выполняющейся программы. Другими словами, процесс в Win32 - это объект, который не выполняется, а просто «владеет» выделенным ей адресным пространством, другими словами, процесс является структурой в памяти. А вот в адресном пространстве процесса находятся не только код и данные, но и потоки - выполняющиеся объекты. При запуске процесса автоматически запускается поток (он называется главным). При остановке главного потока автоматически останавливается и процесс. А так как процесс без потока просто бесцельно занимает ресурсы, то система автоматически уничтожает ставший ненужным процесс. Первичный процесс создается системой при запуске, точно так же при создании первичного процесса в нем создается и поток.
&nbsp;&nbsp; &nbsp;Приложение тоже может создать процесс с главным потоком, используя для этой цели функцию CreateProcess(). Её прототип, находящийся в файле winbase.h, при первой встрече с ним внушает легкий ужас:<BR>
&nbsp;WINBASEAPI BOOL WINAPI CreateProcessA<BR>
&nbsp;&nbsp; &nbsp;(<BR>
&nbsp;&nbsp; &nbsp;LPCSTR lpApplicationName,<BR>
&nbsp;&nbsp; &nbsp;LPSTR ipCommandLine,<BR>
&nbsp;&nbsp; &nbsp;LPSECURITY_ATTRIBUTES lpProcessAttributes,<BR>
&nbsp;&nbsp; &nbsp;LPSECURITY_ATTRIBUTES lpThreadAttributes,<BR>
&nbsp;&nbsp; &nbsp;BOOL blnheritHandles,<BR>
&nbsp;&nbsp; &nbsp;DWORD dwCreationFlags,<BR>
&nbsp;&nbsp; &nbsp;LPVOID lpEnvironment,<BR>
&nbsp;&nbsp; &nbsp;LPCSTR lpCurrentDirectory,<BR>
&nbsp;&nbsp; &nbsp;LPSTARTUPrNFOA lpStartupInfo,<BR>
&nbsp;&nbsp; &nbsp;LPPROCESSJNFORMATION lpProcessInformation<BR>
&nbsp;&nbsp; &nbsp;);<BR>
&nbsp;WINBASEAPI BOOL WINAPI CreateProcessW<BR>
&nbsp;&nbsp; &nbsp;(<BR>
&nbsp;&nbsp; &nbsp;LPCWSTR IpApplicationName,<BR>
&nbsp;&nbsp; &nbsp;LPWSTR lpCommandLine,<BR>
&nbsp;&nbsp; &nbsp;LPSECURITY_ATTRIBUTES lpProcessAttributes,<BR>
&nbsp;&nbsp; &nbsp;LPSECURITY_ATTRIBUTES lpThreadAttributes,<BR>
&nbsp;&nbsp; &nbsp;BOOL blnheritHandles,<BR>
&nbsp;&nbsp; &nbsp;DWORD dwCreationFlags,<BR>
&nbsp;&nbsp; &nbsp;LPVOID lpEnvironment,<BR>
&nbsp;&nbsp; &nbsp;LPCWSTR lpCurrentDirectory,<BR>
&nbsp;&nbsp; &nbsp;LPSTARTUPINFOW lpStartupInfo,<BR>
&nbsp;&nbsp; &nbsp;LPPROCESSJNFORMATION lpProcessInformation<BR>
&nbsp;&nbsp; &nbsp;);<BR>
&nbsp;&nbsp; &nbsp;#ifdef UNICODE<BR>
&nbsp;&nbsp; &nbsp;#define CreateProcess CreateProcessW<BR>
&nbsp;&nbsp; &nbsp;#else<BR>
&nbsp;&nbsp; &nbsp;#define CreateProcess CreateProcessA<BR>
&nbsp;&nbsp; &nbsp;#endif//'UNICODE<BR>

<BR>
&nbsp;&nbsp; &nbsp;В начале работы функция выделяет память для этой структуры, а потом вьделяет память (виртуальную, естественно) для адресного пространства процесса. Если выделение памяти прошло без ошибок, в адресное пространство процесса загружается код исполняемой программы и используемых программой динамических библиотек. Только после этого создается главный поток процесса. Если функции удастся произвести все эти действия без ошибок, то возвращаемое значение будет равно TRUE. FALSE явится индикатором того, что по каким-то причинам процесс не создан.
Перейдем к рассмотрению аргументов функции CreateProcess():
&nbsp;&nbsp; &nbsp;<LI>&nbsp;<strong>Первый аргумент</strong> - lpApplicationName - определяет имя исполняемого файла (обязательно указывать имя и расширение файла, автоматически расширение .ехе не подставляется), для которого создается процесс.
&nbsp;&nbsp; &nbsp;<LI>&nbsp;<strong>Второй аргумент</strong> - lpCommandLine - определяет передаваемую этому файлу командную строку. Если lpApplicationName равен NULL, то первый (до первого пробела) элемент lpCommandLine считается именем исполняемого файла.
Таким образом, имя исполняемого файла можно передавать как в первом, так и во втором аргументе. Но здесь нужно быть внимательным и не допустить, скажем, такой ситуации, когда lpApplicationName равен «Wordpad.exe», a lpCommandLine - «Wordpad.exe MyFile.doc». Нетрудно догадаться к чему это приведет.
&nbsp;&nbsp; &nbsp;<LI>&nbsp;<strong>Третий аргумент</strong> определяют атрибуты доступа к процессу.
&nbsp;&nbsp; &nbsp;<LI>&nbsp;<strong>Четвертый аргумент</strong> определяют атрибуты доступа к потоку.
&nbsp;&nbsp; &nbsp;<LI>&nbsp;<strong>Пятый аргумент</strong>&nbsp;-&nbsp;dwCreationFlag&nbsp;-&nbsp;является комбинацией битовых флагов. Одна группа битовых флагов определяет способ создания процесса.
<H2 class=char> 
Флаги способа создания процесса:
<LI>Флаг DEBUG_PROCESS (0x00000001) устанавливается в тех случаях, когда родительский процесс должен осуществлять отладку порождаемого процесса и всех его потомков. Система будет оповещать родительский процесс о возникновении определенных событий в порождаемом процессе и его потомках.<BR>
<LI>Флаг DEBUG_ONLY_THIS_PROCESS (0x00000002) почти эквивалентен предыдущему, разница состоит в том, что система будет оповещать о событиях только в порождаемом процессе, но не в его потомках.
<LI>Флаг CREATESUSPENDED (0x00000004) указывает, что главный поток порождаемого процесса создается, но не выполняется до вызова функции ResumeThread(). Этот флаг обычно используется в отладчиках.<BR>
<LI>Флаг DETACHEDPROCESS (0x00000008) запрещает создаваемому консольному процессу использовать консоль родительского процесса. Порождаемый процесс вынужден будет вызвать функцию AllocConsoleQ для получения собственной консоли.
<LI>Флаг CREATE_NEW_CONSOLE (0x00000010) указывает на необходимость создания новой консоли для порождаемого процесса. Этот флаг не может использоваться вместе с предыдущим.
<LI>Флаг CREATE_NEW_PROCESS_GROUP (0x00000200) создает группу консольных процессов, которые будут одновременно реагировать на нажатие клавиш Ctrl-C и Ctrl-Break.<BR>
<LI>Флаг CREATE_UNICODE_ENVIRONMENT (0x00000400) означает, что данные, на которые указывает lpEnvironment, используют символы Unicode. По умолчанию считается, что используется ANSI-кодировка.
<LI>Флаг CREATE_SEPARATE_WOW_VDM (0x00000800) используется только при запуске 16-битовых Windows-приложений и указывает, что приложению необходимо выделить отдельную виртуальную машину (Virtual DOS Machine, VDM) (по умолчанию, все 16-битовые Windows-приложения используют одну разделяемую виртуальную машину). Преимуществом выделения отдельной машины является то, что приложение почти не влияет на остальные. Даже зависнув, оно приведет к краху только своей VDM. Недостаток - каждая виртуальная машина требует большого объема памяти.
<LI>Флаг CREATE_SHARED_WOW_VDM (0x00001000) используется при запуске 16-битовых Windows-приложений и указывает на необходимость создания для процесса разделяемой VDM.
<BR>
Флаги класса приоритета процесса:
<LI>NORMAL PRIORITY CLASS       (0x00000020)      Нормальный приоритет
<LI>IDLE_PRIORITY_CLASS	        (0x00000040)     Потоки этого процесса выполняются только тогда, когда система простаивает
<LI>HIGH_PRIORITY_CLASS         (0x00000080)      Приоритет выше нормального, но ниже приоритета реального времени
<LI>REALTIME_PRIORITY_CLASS	(0x00000100)      Самый высокий возможный	приоритет
</H2>

&nbsp;&nbsp; &nbsp;<LI>&nbsp;<strong>Шестой аргумент</strong> - lpEnvironment - обычно равен NULL. Это означает, что порождаемый процесс наследует переменные окружения родительского процесса. Если этот аргумент не равен NULL, то он должен содержать указатель на блок памяти, содержащий те переменные окружения, которыми будет пользоваться порождаемый процесс..
&nbsp;&nbsp; &nbsp;<LI>&nbsp;<strong>Седьмой  аргумент</strong> - lpCurrentDirectory - позволяет установить текущие диск и директорию для порождаемого процесса. Если этот аргумент равен NULL, порождаемый процесс наследует текущие диск и директорию родительского процесса. В противном случае этот аргумент должен указывать на строку, в которой указан полный путь к устанавливаемой текущей директории, включающий и букву дисковода.
&nbsp;&nbsp; &nbsp;<LI>&nbsp;<strong>Восьмой аргумент</strong> - указатель на структуру типа STARTUPINFO. Эта структура, служащая для описания свойств окна, создаваемого в новом процессе, описана в winbase.h следующим образом:<BR>
typedef struct _STARTUPINFOA<BR>
{<BR>
&nbsp;&nbsp; &nbsp;	DWORD cb;<BR>
&nbsp;&nbsp; &nbsp;	LPSTR lpReserved;<BR>
&nbsp;&nbsp; &nbsp;	LPSTR ipDesktop;<BR>
&nbsp;&nbsp; &nbsp;	LPSTR lpTitle;<BR>
&nbsp;&nbsp; &nbsp;	DWORD dwX;<BR>
&nbsp;&nbsp; &nbsp;	DWORD dwY;<BR>
&nbsp;&nbsp; &nbsp;	DWORD dwXSize;<BR> 
&nbsp;&nbsp; &nbsp;	DWORD dwYSize;<BR>
&nbsp;&nbsp; &nbsp;	DWORD dwXCountChars;<BR>
&nbsp;&nbsp; &nbsp;	DWORD dwYCountChars;<BR>
&nbsp;&nbsp; &nbsp;	DWORD dwFillAttribute;<BR>
&nbsp;&nbsp; &nbsp;	DWORD dwFIags;<BR>
&nbsp;&nbsp; &nbsp;	WORD  wShowWindow;<BR>
&nbsp;&nbsp; &nbsp;	WORD  cbReserved2;<BR>
&nbsp;&nbsp; &nbsp;	LPBYTE lpReserved2;<BR>
&nbsp;&nbsp; &nbsp;	HANDLE hStdlnput;<BR>
&nbsp;&nbsp; &nbsp;	HANDLE hStdOutput;<BR>
&nbsp;&nbsp; &nbsp;	HANDLE hStdError;<BR>
} STARTUPINFOA, *LPSTARTUPINFOA;<BR>
typedef struct STARTUPINFOW<BR>
{<BR>
&nbsp;&nbsp; &nbsp;	DWORD cb;<BR>
&nbsp;&nbsp; &nbsp;	LPWSTR lpReserved;<BR>
&nbsp;&nbsp; &nbsp;	LPWSTR IpDesktop;<BR>
&nbsp;&nbsp; &nbsp;	LPWSTR IpTitle;<BR>
&nbsp;&nbsp; &nbsp;	DWORD dwX;
&nbsp;&nbsp; &nbsp;	DWORD dwY;<BR>
&nbsp;&nbsp; &nbsp;	DWORD dwXSize;
&nbsp;&nbsp; &nbsp;	DWORD dwYSize;<BR>
&nbsp;&nbsp; &nbsp;	DWORD dwXCountChars;<BR>
&nbsp;&nbsp; &nbsp;	DWORD dwYCountChars;<BR>
&nbsp;&nbsp; &nbsp;	DWORD dwFillAttribute;<BR>
&nbsp;&nbsp; &nbsp;	DWORD dwFIags;<BR>
&nbsp;&nbsp; &nbsp;	WORD  wShowWindow;<BR>
&nbsp;&nbsp; &nbsp;	WORD  cbReserved2;<BR>
&nbsp;&nbsp; &nbsp;	LPBYTE IpReserved2;<BR>
&nbsp;&nbsp; &nbsp;	HANDLE hStdlnput;<BR>
&nbsp;&nbsp; &nbsp;	HANDLE hStdOutput;<BR>
&nbsp;&nbsp; &nbsp;	HANDLE hStdError;<BR>
} STARTUPINFOW, *LPSTARTUPINFOW;<BR>
#ifdefUNICODE<BR>
typedef STARTUPINFOW STARTUPrNFO; typedef LPSTARTUPrNFOW LPSTARTUPINFO;<BR>
#else<BR>
typedef STARTUPINFOA STARTUPINFO; typedef LPSTARTUPINFOA LPSTARTUPINFO;<BR>
#endif//UNICODE<BR>


<h2 class=char> 
  Поля структуры типа STARTUPINFO:<BR>
  &nbsp;&nbsp; &nbsp;	Первое поле - cb - размер этой структуры. Оно должно быть равно sizeof(STARTUPINFO).	<BR>
  &nbsp;&nbsp; &nbsp;	Второе поле - lpReserved - зарезервировано и должно быть равно NULL.			<BR>
  &nbsp;&nbsp; &nbsp;	Третье поле - lpDesktop - в Windows'95 просто игнорируется.<br>
  &nbsp;&nbsp; &nbsp;	Четвертое поле - lpTitle - определяет заголовок консольного приложения. Для GUI или приложений, не создающих новой консоли, должен 			быть равным NULL.		<BR>
  &nbsp;&nbsp; &nbsp;	Поля с пятого по восьмое включительно определяют положение окна и его размеры (dwX, dwY - координаты верхнего левого угла окна в 				пикселах, dwXSize, dwYSize - ширина и высота окна в пикселах).<BR>
  &nbsp;&nbsp; &nbsp;	Девятое и десятое поля (dwXCountChars, dwYCountChars) определяют ширину и высоту окна консоли в символах (не пикселах!).<BR>
  &nbsp;&nbsp; &nbsp;	Одиннадцатое поле - dwFillAttribute - определяет атрибуты консольного окна.<BR>
  &nbsp;&nbsp; &nbsp;	Двенадцатое поле - dwFlags - используется для того, чтобы определить, какие поля структуры типа STARTUPINFO будут использоваться при 			создании окна порождаемым процессом. Это поле представляет собой комбинацию битовых флагов.<BR>
  &nbsp;&nbsp; &nbsp;	Тринадцатое поле - wShowWindow - определяет, каким образом окно будет отображено (помните функцию ShowWindow())? Значение этого поля 				игнорируется, если только в dwFlags не установлен флаг STARTFUSESHOWWINDOW. Возможные значения этого поля - те же константы, 					начинающиеся с SW_, которые используются в функции ShowWindow().<BR>
  &nbsp;&nbsp; &nbsp;	Четырнадцатое и пятнадцатое поля, - cbReserved2 и lpReserved2 зарезервированы. Должны инициализироваться нулем и NULL оответственно.<BR>
  &nbsp;&nbsp; &nbsp;	Шестнадцатое, семнадцатое и восемнадцатое поля - hStdlnput, hStdOutput и hStdError - определяют хэндлы стандартных потоков<BR> ввода-вывода.<BR><BR>
  
  Флаги, определяющие, в каких полях структуры типра STARTUPINFO содержится информация:
  
  <BR>&nbsp;&nbsp; &nbsp;STARTF_USESHOWWINDOW	(0x00000001)	Если флаг не установлен, поле wShowWindow игнорируется
  <BR>&nbsp;&nbsp; &nbsp;STARTF_USESIZE		(0x00000002)	Если флаг не установлен, поля dwXSize и dwYSize игнорируются
  <BR>&nbsp;&nbsp; &nbsp;STARTF_USEPOSITION	(0x00000004)	Если флаг не установлен, поля dwX и dwY игнорируются 
  <BR>&nbsp;&nbsp; &nbsp;STARTF_USECOUNTCHARS	(0x00000008)	Если флаг не установлен, поля dwXCountChars и dwYCounChars игнорируются
  <BR>&nbsp;&nbsp; &nbsp;STARTF_USEFILLATTRIBUTE	(0x00000010)	Если флаг не установлен, поле dwFillAttribute игнорируется
  <BR>&nbsp;&nbsp; &nbsp;STARTF_RUNFULLSCREEN	(0x00000020)	Понятно по названию
  <BR>&nbsp;&nbsp; &nbsp;STARTF_FORCEONFEEDBACK	(0x00000040)	Курсор становится «песочными часами» на две секунды, за которые должно произойти обращение к 							GUI, после чего за 5 секунд должно быть создано окно и еще за 5 секунд оно должно перерисоваться
  <BR>&nbsp;&nbsp; &nbsp;STARTF_FORCEOFFFEEDBACK	(0x00000080)	При создании процесса форма курсора не меняется
  <BR>&nbsp;&nbsp; &nbsp;STARTF_USESTDHANDLES	(0x00000100)	Если флаг установлен, то используются потоки, хэндлы которых определены полями hStdlnput, hStdOutput, hStdError
  <BR>&nbsp;&nbsp; &nbsp;STARTF_USEHOTKEY		(0x00000200)</h2>
    
<LI>&nbsp;<strong>Последний аргумент</strong> функции CreateProcess() - lpProcessInformation, указывающий на структуру типа PROCESSINFORMATION, в которую записывается информация о порожденном процессе после его создания. Структура описана в файле winbase.h следующим образом:<BR>
typedef struct PROCESSINFORMATION <BR>
{<BR>
&nbsp;&nbsp; &nbsp;	HANDLE hProcess;<BR>
&nbsp;&nbsp; &nbsp;	HANDLE hThread;<BR>
&nbsp;&nbsp; &nbsp;	DWORD dwProcessId;<BR>
&nbsp;&nbsp; &nbsp;	DWORD dwThreadId;<BR>
} PROCESSJNFORMATION, *PPROCESSJNFORMATION, *LPPROCESS_INFORMATION;<BR>

В первое поле - hProcess - система записывает хэндл созданного процесса, во второе - hThread - хэндл потока. Поля dwProcessId и dwThreadld являются уникальными идентификаторами процесса и потока соответственно. Рекомендую обратить особое внимание на последние два поля. Дело в том, что Win32, если идентификатор освобожден, может повторно использовать его. К примеру, пусть процессу присвоен идентификатор 0x00001111. После завершения процесса идентификатор освобождается и какому-нибудь новому процессу может опять быть присвоен тот же идентификатор 0x00001111. Это необходимо учитывать при написании программ.


&nbsp;&nbsp; &nbsp;<A name=metod_destroyproc></A><H3><CENTER>ЗАВЕРШЕНИЕ ПРОЦЕССА</CENTER></H3>
&nbsp;&nbsp; &nbsp;Процесс может быть завершен вызовом одной из двух функций - ExitProcess() или TerminateProcess().<BR>
<U>ФУНКЦИЯ EXITPROCESS():</U><BR>
В обычных условиях процесс завершается тогда, когда один из принадлежащих ему потоков вызывает функцию ExitProcess(), которая описана в файле winbase.h следующим образом:<BR>
WINBASEAPI VOID WTNAPI ExitProcess(UINT uExitCode);<BR>
Cледует обратить внимание на тот факт, что завершение процесса начинается изнутри процесса. Почему так сделано? Во-первых, только поток процесса знает, когда он выполнил свою работу и когда ему необходимо завершиться. Во-вторых, только процесс в тот момент, когда он узнает о необходимости завершения, может оповестить об этом все принадлежащие ему потоки и произвести нормальное завершение. Извне процесса эти действия произвести почти невозможно.<BR>
Если говорить более конкретно, то при завершении процесса производятся следующие действия:
&nbsp;&nbsp; &nbsp;<LI>&nbsp	вызываются функции деинициализации всех подключенных библиотек динамической компоновки, т. е. происходит нормальное завершение всех подключенных DLL;
&nbsp;&nbsp; &nbsp;<LI>&nbsp	закрываются и/или уничтожаются все объекты, открытые и/или созданные процессом;<BR>
&nbsp;&nbsp; &nbsp;<LI>&nbsp	состояние процесса изменяется на «освобожденный» (signaled), что является сигналом для всех потоков, ожидающих завершения процесса;
&nbsp;&nbsp; &nbsp;<LI>&nbsp	состояние всех потоков изменяется на «освобожденный» (signaled), что является сигналом для всех потоков других процессов, которые ожидают завершения потоков текущего процесса; 
&nbsp;&nbsp; &nbsp;<LI>&nbspкод завершения меняется со STILLACTIVE на код, записываемый в uExitCode;
&nbsp;&nbsp; &nbsp;<LI>&nbsp	счетчик числа пользователей процесса уменьшается на единицу
<H2 class=char>заметим, что данные процесса удаляются из памяти, но сам объект остается в памяти до того момента, пока счетчик пользователей не достигнет нулевого значения, или, другими словами, пока не будут закрыты все хэндлы процесса. Определить, завершен ли процесс можно с помощью функции GetExitProcessCode(), которая в случае незавершенности процесса возвращает STILLACTIVE.</H2>

Необходимо отметить, что завершение процесса не приводит к завершению порожденных им процессов.

Сразу после деинициализации и выгрузки библиотек из памяти, но до своего завершения, функция заносит в параметр uExitCode код завершения. После этого процесс можно считать полностью завершенным.<BR><BR>

<U>ФУНКЦИЯ TERMINATEPROCESS()</U><BR>
Эта функция является аварийным средством завершения процесса и её рекомендуется использовать только в крайнем случае. Она описана в том же winbase.h:<BR>
WINBASEAPI BOOL WINAPI TerminateProcess(HANDLE hProcess,UINT uExitCode);<BR>
Функция используется только тогда, когда иными средствами завершить процесс не удается. С этой целью извне (!), а не изнутри процесса вызывается функция TerminateProcess(), которая и завершает процесс. Но в данном случае не освобождаются используемые процессом DLL, хотя все используемые объекты освобождаются. Освобождается также и память, занимаемая процессом. Число пользователей процесса также уменьшается.
Обычно один процесс запускает другой как обособленный и после запуска забывает о нем. Для того чтобы порожденный процесс мог быть завершен, сразу после создания процесса порождающий процесс должен закрыть хэндл порожденного процесса и его потока. Делается это примерно следующим образом:<BR>
PROCESS_INFORMATION ProcessInforrnation;<BR>
BOOL hMyProcess;<BR>
if (hMyProcess = CreateProcess(........, &ProcessInformation))<BR>
{<BR>
&nbsp;&nbsp; &nbsp;	CloseHandle(ProcessInformation.hThread);  <BR>
&nbsp;&nbsp; &nbsp;	CloseHandle(ProcessInformation.hProcess); <BR>
}<BR>
<BR>
 
О процессах можно рассказать намного больше, но надеюсь, что написанного хватит для того, чтобы приступить к программированию.






&nbsp;&nbsp; &nbsp;<A name=metod_worktr></A><H3><CENTER>Создание рабочего потока</CENTER></H3>

&nbsp;&nbsp; &nbspОдной из областей применения потоков является создание рабочих потоков. Они обычно используются для выполнения фоновых задач, выполнение которых занимает достаточно много времени, и в процессе выполнения которых у пользователя может появиться потребность продолжить работу с данным приложением. К таким задачам относятся различные вычисления и фоновая печать документов.
Создание рабочего потока является довольно-таки простой задачей. Необходимо выполнить всего две операции: создать исполняющую функцию потока и запустить поток. При этом нет необходимости создавать класс, производный от класса cwinThread. В большинстве случаев этот класс может использоваться без перегрузки его функций, однако в некоторых случаях такая перегрузка необходима.
Для создания рабочего потока необходимо вызвать функцию AfxBeginThread и передать ей в качестве аргументов следующую информацию:
&nbsp;&nbsp;<LI>&nbsp;&nbsp;Адрес исполняющей функции потока
&nbsp;&nbsp;<LI>&nbsp;&nbsp;Значение аргумента исполняющей функции потока
Кроме того, данная функция имеет еще четыре необязательных аргумента:
&nbsp;&nbsp;<LI>&nbsp;&nbsp;Приоритет потока. По умолчанию используется нормальный приоритет. Возможные значения приоритета перечислены в описании функции
: :SetThreadPriority для процессов.
&nbsp;&nbsp;<LI>&nbsp;&nbsp;Предполагаемый размер стека, используемого потоком. По умолчаниюдля создаваемого потока создается стек того же размера, что и для вызывающего
&nbsp;&nbsp;<LI>&nbsp;&nbsp;Значение CREATE_SUSPENDED, если поток создается в приостановленном состоянии. По умолчанию в этом аргументе передается нулевое значение, означающее нормальное начало работы потока
&nbsp;&nbsp;<LI>&nbsp;&nbsp;Атрибуты безопасности потока. По умолчанию для потока выбираются теже атрибуты безопасности, что и для вызывающего потока
<BR>&nbsp;&nbsp; &nbsp;Функция AfxBeginThread создает и инициализирует объект класса cwinThread, запускает его на исполнение и возвращает его адрес пользователю, чтобы он мог на него ссылаться. Если в процессе выполнения функции AfxBeginThread возникает ошибка, то при выходе из функции необходимо проверить, что все объекты, созданные во время выполнения, будут соответствующим образом уничтожены.
В исполняющей функции потока Поток:функция выполняются все действия, предусмотренные для данного потока. При вызове исполняющей функции поток начинает работу, а при выходе из нее — завершает. Эта функция имеет следующий формат:
UINT MyControllingFunction( LPVOID pParam);
Аргументом данной функции является 32-разрядная величина. Значение, передаваемое функции в этом аргументе, совпадает со значением второго аргумента функции AfxBeginThread, используемой для создания данного потока. Исполняющая функция может интерпретировать это значение любым
образом. Оно может быть интерпретировано как скалярная величина, как указатель на объект структуры, содержащей несколько параметров, или может вообще игнорироваться. Если аргумент функции представляет собой указатель на объект структуры, то данный объект может использоваться не только для передачи данных в процедуру, но и для передачи обработанных данных приложению.
Завершая свою работу, функция должна возвратить значение типа UINT, указывающее на причину завершения функции. Обычно возврат нулевого значения говорит о нормальном завершении функции, а все остальные значения — о возможных ошибках. Эти значения определяются пользователем при написании исполняющей функции. Некоторые потоки могут подсчитывать и возвращать число вызовов объектов определенных классов.
Ниже приведен пример исполняющей функции потока и ее вызова из приложения:
<BR>&nbsp;&nbsp; &nbsp;UINT MyThreadProc( LPVOID pParam)
<BR>&nbsp;&nbsp;{
<BR>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;CMyObject* pObject = (CMyObject*)pParam;
<BR>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;if (pObject == NULL ||!pObject->IsKindOf(RUNTIME_CLASS(CMyObject))) return 1;// Если pObject не указывает на объект
<BR>
<BR>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;// Работа с объектом
<BR>
<BR>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;return 0;   // Успешное завершение потока
<BR>&nbsp;&nbsp;&nbsp}
<BR>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;// Вызов в одной из функций приложения

<BR>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;/----/
<BR>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;pNewObject = new CMyObject;
<BR>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;AfxBeginThread(MyThreadProc, pNewObject);
<BR>&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;/----/
<BR><BR>

<A name=metod_inter></A><H3><CENTER>Создание интерфейсных потоков</CENTER></H3>
&nbsp;&nbsp; &nbsp;Поток для реализациилолъзовательского интерфейса обычно используется при организации ввода информации независимо от выполнения основного потока приложения. Основной поток приложения (производный от класса cwinApp) запускается вместе с приложением и завершается вместе с ним. Для создания интерфейсного потока необходимо создать пользовательский класс, производный от класса cwinThread. При объявлении и при реализации данного класса следует использовать макросы DECLAREDYNACREATE И IMPLEMENT_DYNACREATE. В этом классе необходимо перегрузить несколько функций, описание которых приведено ниже.
 

Перегружаемые функции-члены класса cwinThread:

&nbsp; &nbsp;<LI>Exitinstance&nbsp;-&nbsp;Осуществляет уничтожение объектов после завершения потока. Обычно перегружается
&nbsp; &nbsp;<LI>Initinstance&nbsp;-&nbsp;Производит инициализацию экземпляра потока. Должна перегружаться
&nbsp; &nbsp;<LI>Onidle&nbsp;-&nbsp;Производит обработку во время ожидания процесса. Обычно не перегружается
&nbsp; &nbsp;<LI>PreTranslateMessage&nbsp&nbsp;-&nbsp;Производит фильтрацию сообщений перед их передачей функциям TranslateMessage И DispatchMessage. Обычно не перегружается
&nbsp; &nbsp;<LI>ProcessWndProcException&nbsp;-&nbsp;Перехватывает необработанные исключения, вызванные сообщениями и обработчиками команд потока. Обычно не перегружается
&nbsp; &nbsp;<LI>Run&nbsp;-&nbsp;Исполняющая функция потока. Содержит цикл обработки сообщений. Перегружается очень редко<BR>
Для создания интерфейсного потока необходимо вызвать функцию AfxBeginThread и передать в нее в качестве аргумента имя класса, производного от класса cwinThread. Кроме того, данная функция имеет еще четыре необязательных аргумента:
&nbsp; &nbsp;<LI>Приоритет потока. По умолчанию используется нормальный приоритет. Возможные значения приоритета перечислены в описании функции
: :SetThreadPriority
&nbsp; &nbsp;<LI>Предполагаемый размер стека, используемого потоком. По умолчанию для создаваемого потока создается стек того же размера, что и для вызывающего
&nbsp; &nbsp;<LI>Значение CREATESUSPENDED, если поток создается в приостановленном
состоянии. По умолчанию в этом аргументе передается нулевое значение,
означающее нормальное начало работы потока
&nbsp; &nbsp;<LI>Атрибуты безопасности потока. По умолчанию для потока выбираются те
же атрибуты безопасности, что и для вызывающего потока
Функция AfxBeginThread выполняет основную работу по созданию потока. Она создает новый объект пользовательского класса, инициализирует его, используя информацию, предоставленную пользователем, и вызывает функцию cwinThread::createThread. Если в процессе выполнения функции AfxBeginThread возникает ошибка, при выходе из нее необходимо проверить, что все объекты, созданные во время выполнения, будут соответствующим образом уничтожены.




<A name=metod_worktrapi></A><H3><CENTER>СОЗДАНИЕ ПОТОКА WINAPI</CENTER></H3>
&nbsp;&nbsp; &nbsp;Для создания потока используется функция CreateThread() (аналог WinMain()), одним из аргументов которой является указатель на функцию потока (аналог оконной функции). Она описана в файле winbase.h:<BR>
	WINBASEAPI HANDLE WINAPI CreateThread<BR>
	(<BR>
&nbsp;&nbsp; &nbsp;	LPSECURITY_ATTRIBUTESlpThreadAttributes,<BR>
&nbsp;&nbsp; &nbsp;	DWORD dwStackSize,<BR>
&nbsp;&nbsp; &nbsp;	LPTHREAD_START_ROUTINEIpStartAddress,<BR>
&nbsp;&nbsp; &nbsp;	LPVOID IpParameter,<BR>
&nbsp;&nbsp; &nbsp;	DWORD dwCreationFlags,<BR> 
&nbsp;&nbsp; &nbsp;	LPDWORD lpThreadld<BR>
	);<BR>
При вызове этой функции происходит следующее:
<LI>в памяти создаются все необходимые для управления потоком структуры (назовем их объектом «поток»);
<LI>код завершения потока инициализируется значением STILLACTIVE;
<LI>создается структура типа CONTEXT для потока;
<LI>создается стек потока;
<LI>инициализируется регистр - указатель стека в структуре типа CONTEXT так, чтобы он указывал на верхнюю границу стека, а регистр - указатель команд - на точку входа функции потока.<BR>
<BR>
<U>АРГУМЕНТЫ ФУНКЦИИ CREATETHREADO</U>
<BR>&nbsp;&nbsp; &nbsp;Первый аргумент - lpThreadAttributes - является указателем на структуру типа SECURITY_ATTRIBUTES. Так как в Windows'95 атрибуты безопасности не используются, то обычно этот аргумент равен NULL.
<BR>&nbsp;&nbsp; &nbsp;Второй аргумент - dwStackSize - определяет размер выделяемого потоку стека. Если в качестве этого параметра указан 0, то поток будет иметь стек такого же размера, как и у породившего его потока.
<BR>&nbsp;&nbsp; &nbsp;Третий аргумент этой функции - lpStartAddress - собственно и определяет поток, так как является адресом точки входа функции потока. <BR>&nbsp;&nbsp; &nbsp;Функция потока может иметь имя, определяемое программистом, но должна иметь следующий прототип:
DWORD WINAPI ThreadFunction(LPVOID IpParameter);
<BR>&nbsp;&nbsp; &nbsp;Четвертый аргумент функции CreateThread() - это параметр, передаваемый функции потока. Что и каким образом передается в этом параметре, совершенно неважно. Это могут быть всевозможные данные, которые функция потока может использовать для своей работы.
<BR>&nbsp;&nbsp; &nbsp;Если следующий аргумент - dwCreationFlags - равен нулю, то выполнение потока начнется немедленно. Если этот аргумент будет равен CREATESUSPENDED, то начало выполнение потока будет задержано до определенных событий, например, до вызова функции ResumeThread().
<BR>&nbsp;&nbsp; &nbsp;И наконец, в значение, определяемое последним аргументом, lpThreadld, записывается идентификатор созданного потока.
<BR>&nbsp;&nbsp; &nbsp;Значение, возвращаемое функцией, является хэндлом этого потока.<BR>


<A name=metod_destroytrapi></A><H3><CENTER>ЗАВЕРШЕНИЕ ПОТОКА</CENTER></H3>
&nbsp;&nbsp; &nbsp;Как и процесс, поток может быть завершен двумя способами - вызовом функции ExitThread() и обращением к функции TerminateThread(). Отличаются они друг от друга примерно тем же, что и функции ExitProcess() и TerminateProcess(). Первая функция, ExitThread(), используется для нормального завершения потока. Естественно, что она вызывается изнутри потока. Она описана в файле winbase.h:<BR>
&nbsp;&nbsp; &nbsp;WINBASEAPI VOID WINAPI ExitThread(DWORD dwExitCode);<BR>
Единственным ее аргументом является двойное слово, в которое будет помещен код возврата этой функции.
Функцию TerminateProcess(), описанную в том же файле winbase.h следующим образом:<BR>
WINBASEAPI BOOL WINAPI TerminateThread(HANDLE hThread,DWORD dwExitCode);<BR>
следует вызывать только в крайних случаях, когда поток завис, и ни на какие действия пользователя не реагирует. Функция вызывается из какого-либо внешнего (по отношению к завершаемому) потока, а ее аргументами являются хэндл завершаемого потока и двойное слово, в которое будет записан код завершения потока.
Осталось только узнать, что происходит при завершении потока.
<LI>Во-первых, освобождаются или удаляются все занятые или созданные объекты. Это действие является стандартным и ничего особенного собой не представляет.
<LI>Во-вторых, поток получает статус незанятого (signaled).
<LI>В-третьих, код завершения процесса меняется со STILL_ACTIVE на указанный при вызове завершающей поток функции.
<LI>В-четвертых, уменьшается счетчик пользователей потока. Если пользователей потока больше не осталось, и поток является единственным потоком процесса, то завершается и процесс.



<A name=metod_example></A><H3><CENTER>Примеры использования</CENTER></H3>
    

  <h2><strong><U><u>Пример 1:</u></strong></U> Программа, демонстрирующая, как наследуются описатели объектов ядра. Будем считать, что процесс А порождает процесс В и заносит в параметр lpsaProcess адрес структуры SECURITY_ATTRIBUTES, в которой элемент bInheritHandle установлен как TRUE. Одновременно параметр lpsaThread указывает на другую структуру SECURITY_ATTRIBUTES, в которой значение элемента bInheritHandle — FALSE.
    Создавая процесс В, система формирует объекты ядра «процесс» и «поток», а затем — в структуре, на которую указывает параметр ippiProdnfo, — возвращает их описатели процессу А, и с этого момента тот может манипулировать только что созданными объектами «процесс» и «поток».
    Теперь предположим, что процесс А собирается вторично вызвать CreateProcess, чтобы породить процесс С. Сначала ему нужно определить, стоит ли предоставлять процессу С доступ к своим объектам ядра. Для этого используется параметр fInheritHandles. Если он приравнен TRUE, система передает процессу С все наследуемые описатели. В этом случае наследуется и описатель объекта ядра «процесс» процесса В. А вот описатель объекта «первичный поток» процесса В не наследуется ни при каком значении fInheritHandles. Кроме того, если процесс А вызывает CreateProcess, передавая через параметр fInheritHandles значе¬ние FALSE, процесс С не наследует никаких описателей, используемых в данный момент процессом А. </h2>

  <h2>#include "windows.h"<BR>
    int WINAPI WinMain(HINSTANCE hinstExe, HINSTANCE hinstExePrev, LPSTR lpszCmdLine, int nCmdShow) <BR>
    {<BR>
  &nbsp;&nbsp; &nbsp;	STARTUPINFO si;<BR>
  &nbsp;&nbsp; &nbsp;	SECURITY_ATTRIBUTES saProcess, saThread;<BR>
  &nbsp;&nbsp; &nbsp;	PROCESS_INFORMATION piProcessB, piProcessC;<BR>
  &nbsp;&nbsp; &nbsp;	// готовим структуру STARTUPINFO для порождаемых процессов<BR>
  &nbsp;&nbsp; &nbsp;	 ZeroMemory(&si, sizeof(si)); si.cb = sizeof(si);<BR>
  &nbsp;&nbsp; &nbsp;	// готовимся к созданию процесса В из процесса А;<BR>
  &nbsp;&nbsp; &nbsp;	// описатель, идентифицирующий новый объект "процесс",<BR>
  &nbsp;&nbsp; &nbsp;	// должен быть наследуемым<BR>
  &nbsp;&nbsp; &nbsp;	saProcess.nLength = sizeof(saProcess);<BR>
  &nbsp;&nbsp; &nbsp;	saProcess.lpSecurityDescriptor = NULL;<BR>
  &nbsp;&nbsp; &nbsp;	saProcess.bInheritHandle = TRUE;<BR>
  &nbsp;&nbsp; &nbsp;	// описатель, идентифицирующий новый объект "поток", // НЕ должен быть наследуемым<BR>
  &nbsp;&nbsp; &nbsp;	saThread.nLength = sizeof(saThread);<BR>
  &nbsp;&nbsp; &nbsp;	saThread.lpSecurityDescriptor = NULL;<BR>
  &nbsp;&nbsp; &nbsp;	saThread.bInheritHandle = FALSE;<BR>
  &nbsp;&nbsp; &nbsp;	// порождаем процесс В<BR>
  &nbsp;&nbsp; &nbsp;	CreateProcess(NULL, "ProcessB", &saProcess, &saThread, FALSE, 0, NULL, NULL, &si, &piProcessB);<BR>
  &nbsp;&nbsp; &nbsp;	// Структура pi содержит два описателя, относящиеся к процессу А:<BR>
  &nbsp;&nbsp; &nbsp;	// hProcess, который идентифицирует объект "процесс" процесса В<BR>
  &nbsp;&nbsp; &nbsp;	// и является наследуемым, и hThread, который идентифицирует объект<BR>
  &nbsp;&nbsp; &nbsp;	// "первичный поток" процесса В и НЕ является наследуемым.<BR>
  &nbsp;&nbsp; &nbsp;	// Готовимся создать процесс С из процесса А.<BR>
  &nbsp;&nbsp; &nbsp;	// Так как в ipsaProcess и ipsaThread передаются NULL, описатели<BR>
  &nbsp;&nbsp; &nbsp;	// объектов "процесс" и "первичный поток" процесса С считаются <BR>
  &nbsp;&nbsp; &nbsp;	// ненаследуемыми по умолчанию.<BR>
  &nbsp;&nbsp; &nbsp;	// Если процесс А создаст еще один процесс, тот НЕ унаследует<BR>
  &nbsp;&nbsp; &nbsp;	// описатели объектов "процесс" и "первичный поток" процесса С.<BR>
  &nbsp;&nbsp; &nbsp;	// Поскольку в параметре flnheritHandles передается TRUE,<BR>
  &nbsp;&nbsp; &nbsp;	// процесс С унаследует описатель, идентифицирующий объект<BR>
  &nbsp;&nbsp; &nbsp;	// "процесс" процесса В, но НЕ описатель, идентифицирующий объект<BR>
  &nbsp;&nbsp; &nbsp;	// "первичный поток" того же процесса.<BR>
  &nbsp;&nbsp; &nbsp;	CreateProcess(NULL, "ProcessC", NULL, NULL, TRUE, 0, NULL, NULL, &si, &piProcessC);<BR>
  &nbsp;&nbsp; &nbsp;	return 0;<BR>
    }
  &nbsp;&nbsp; &nbsp;</h2>
  <h2><strong><U>Пример 2:</strong></U> Если Вы хотите создать новый процесс, заставить его выполнить какие-либо операции и дождаться их результатов, напишите примерно такой код:</h2>
  <h2> PROCESS_INFORMATION pi;<BR>
    DWORD dwExitCode;<BR>
    BOOL fSuccess = CreateProcess(..., &pi);<BR>
    if (fSuccess)<BR>
    {<BR>
&nbsp;&nbsp; &nbsp;	// закрывайте описатель потока, как только необходимость в нем отпадает!<BR>
&nbsp;&nbsp; &nbsp;	CloseHandle(pi.hThread):<BR>
&nbsp;&nbsp; &nbsp;	WaitForSingleObject(pi.hProcess, INFINITE);<BR>
&nbsp;&nbsp; &nbsp;	// процесс завершился<BR>
&nbsp;&nbsp; &nbsp;	GetExitCodeProcess(pi.hProcess, SdwExitCode);<BR>
&nbsp;&nbsp; &nbsp;	// закрывайте описатель процесса, как только необходимость в нем отпадает!<BR>
&nbsp;&nbsp; &nbsp;	CloseHandle(pi.hProcess);<BR>
}<BR>
  <BR>
  <BR>
  <A name=task></A>  </h2>
<P><U>Задания</U><BR><BR>
  </P>
  <I><OL type=1 start=1 >
  <B><LI>Породить цепочку процессов. Предыдущие процессы в цепочке должны завершаться по завершении любого из следующих.
  <LI>Породить несколько процессов из одного. Все процессы должны завершаться по завершению первого.
  <LI>Породить два процесса. По завершению одного (любого) из них второй должен сразу же порождать еще один процесс. Предусмотреть путь корректного завершения работы обоих процессов.
  <LI>Написать менеджер задач, порождающий и уничтожающий процессы по команде пользователя.
  <LI>Написать менеджер задач, порождающий процессы. По команде пользователя процессы с выбранным приоритетом уничтожаются.
  <LI>Разработать индикатор, показывающий, что выбранные процессы продолжают выполняться или завершены.
  <LI>Разработать индикатор, показывающий приоритет выполняющихся процессов.
  <LI>Разработать менеджер процессов, уничтожающий процессы, выполняющиеся дольше заданного срока.
  <LI>Разработать менеджер процессов, уничтожающий процессы, имеющие приоритет, меньший заданного.
  <LI>Продемонстрировать взаимодействие трех процессов (двух клиентов и одного сервера). Для всех своих клиентов (и их могло быть не два, а сколько угодно) сервер предоставляет один общий канал. Поскольку клиенты не могут функционировать без сервера, то при закрытии сервера они также закрываются. Буфера взаимодействия между ними нет.
  <LI>Продемонстрировать взаимодействие трех процессов (двух клиентов и одного сервера). Для каждого клиента у сервера выделен собственный канал.
  <LI>Продемонстрировать взаимодействие трех процессов (двух клиентов и одного сервера). Для каждого клиента у сервера выделен собственный канал. Прием данных от каждого клиента зависит от некоторого условия, например, от состояния флажка CheckBox.</B></OL>
  </I>
  
  <BR>
  <BR>
  <A name=control></A>
  <P><U>Контрольные вопросы</U><BR><BR>
  </P>
  <I><OL type=1 start=1 ><B>
  <LI>Что такое контекст процесса?
  <LI>Что такое идентификатор процесса, описатель (дескриптор) процесса?
  <LI>Как соотносятся процесс и нить?
  <LI>Перечислите все способы завершения процесса.
  <LI>Назовите основные типы процессов.</B>
    
    
  </OL>
  </I>
  
</BODY>
</HTML> 