<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<TITLE> Методические указания по дисциплине "Системы реального времени"</TITLE>
<STYLE> 
@import URL("stil.css"); 
</STYLE> 
</HEAD>
<BODY background="images/whttxtr2.jpg">
<H3><CENTER><U>Лабораторная работа №3</U>
<BR>"Работа с разделяемой памятью и файлами в асинхронном режиме"</CENTER></H3>
<P>
<i>Для выполнения лабораторной работы и ответа на контрольные вопросы возможно использование следующих материалов:</i>
<H2><UL type=disc> 
<LI><A href="WinApi_rus.hlp">Справка по WinApi</A>
<LI><i>Румянцев П.В.&nbsp; <b>Азбука программировани на Win32 API </b></i>
<LI><i>Ганеев Р.М. &nbsp;<b>Проектирование интерфейса пользователя средствами Win32 API
</b></i>
<LI><i>Румянцев П.В. &nbsp;<b>Работа с файлами в Win32 API </b></i>
</UL></H2>


<P>
<A href="#aim"><B>Цель работы</a><BR>
&nbsp;&nbsp; &nbsp;<A href="#poryadok"><B>Порядок выполнения работы</a><BR>
&nbsp;&nbsp; &nbsp;<A href="#metod">Методические указания</a><BR>
&nbsp;&nbsp; &nbsp;<A href="#task">Задания</a><BR>
&nbsp;&nbsp; &nbsp;<A href="#control">Контрольные вопросы</B></a></P>
<A name=aim></A>
<p>
<P><b><U>Цель работы:</U></b>:  
<H2><UL type=disc> 
<LI>изучение способов работы с разделяемой памятью на основе файлов проецируемых в память;
<LI>изучение способов синхронизации процессов и нитей с использованием мьютексов (mutex) и семафоров;
<LI>изучение способов работы с файлами в Win32 API
<LI>изучение асинхронного режима работы с файлами
</UL></H2>

<A name=poryadok></A>
<p>
<P><b><U>Порядок выполнения работы</U></b>:  
<H2><UL type=i> 
<LI>изучить системные вызовы для работы с файлами в Win32: <i>CreateFile, CloseHandle, ReadFile, WriteFile, CancelIo, 
WaitForSingleObject, WaitForMultipleObjects, GetFilePointer, SetFilePointer, FindFirstFile, FindNextFile, FindClose, SearchFile
</i>
<LI>изучить системные вызовы для работы с разделяемой памятью: <i>CreateFileMapping, OpenFileMapping, MapViewOfFile, 
UnmapViewOfFile, CloseHandle, CreateMutex, OpenMutex, CreateSemaphore, OpenSemaphore, ReleaseMutex, ReleaseSemaphore, 
WaitForSingleObject, WaitForMultipleObjects</i>.
<LI>Разработать программу в соответствии с заданием на нее и указаниями по выполнению работы. 
<LI>Составить отчет о выполнении лабораторной работы, включив в него стандартные разделы. 
</UL></H2>


<A name=metod></A>
<P><U><b>Методические указания</b></U><BR><BR>
<p>При выполнении данной лабораторной работы запрещается пользоваться группами функций Win32 API CopyFile… и MoveFile…, 
а также функциями библиотеки shell32.dll.
<p>Для создания/открытия файла в Win32 API используется функция CreateFile (параметр dwCreationDisposition используется 
для задания режима открытия или создания файла). Чтение из файла и запись в файл реализуются с помощью функций ReadFile и 
WriteFile. Дескриптор файла закрывается с помощью стандартной функции CloseHandle.
<p>Поиск файла в заданном каталоге возможен с помощью функций FindFirstFile, FindNextFile, FindClose. Поиск файла по путям 
поиска производится с помощью функции SearchFile.
<p>В Win32 API реализована возможность задания асинхронного режима работы с файлами. Этот режим работает только в 
Windows NT-based операционных системах. При использовании этого режима чтение и запись в файл реализуются параллельно работе 
нити, задавшей файловую операцию. Для обеспечения возможности асинхронного режима работы с файлом необходимо в параметре 
dwFlagsAndAttributes функции CreateFile задать битовый флаг FILE_FLAG_OVERLAPPED. 
<p>После этого параметр lpOverlapped у функций чтения и записи в файл должен являться указателем на экземпляр структуры 
OVERLAPPED, представленной ниже:
<p>typedef struct _OVERLAPPED {
<p>&nbsp;&nbsp;&nbsp;  ULONG_PTR Internal;
<p>&nbsp;&nbsp;&nbsp;  ULONG_PTR InternalHigh;
<p>&nbsp;&nbsp;&nbsp;  DWORD Offset;
<p>&nbsp;&nbsp;&nbsp;  DWORD OffsetHigh;
<p>&nbsp;&nbsp;&nbsp;  HANDLE hEvent;
<p>} OVERLAPPED;
<p align="justify">Параметры структуры Offset и OffsetHigh задают начальное смещение от начала файла для выполнения файловой операции. 
Дескриптор hEvent должен быть верным дескриптором события, порожденного с помощью функции CreateEvent. 
Параметры Internal и InternalHigh используются самой ОС.
<p align="justify">После задания асинхронной операции с файлом функция ReadFile или WriteFile немедленно возвращает управление. 
После окончания файловой операции событие hEvent переходит в сигнальное состояние и может быть проверено с помощью 
стандартных WaitFor-функций.
<p>Функция CancelIo немедленно прекращает все ждущие асинхронные файловые операции по заданному дескриптору файла для текущей нити.
<p align="justify">Для получения разделяемой памяти необходимо создать файл, проецируемый в память не на диске, а в свопинге системы, 
с помощью функции CreateFileMapping. Это достигается заданием в первом параметре hFile значения INVALID_HANDLE_VALUE. 
Проекция файла на адресное пространство процесса задается с помощью функций MapViewOfFile или MapViewOfFileEx. 
По окончании работы следует вызвать функции UnmapViewOfFile и CloseHandle для дескриптора спроецированного в память файла.
<p>Мьютексы и семафоры позволяют синхронизировать нити в разных процессах (как и события), поскольку являются объектами 
операционной системы. 
<p>Мьютекс – это объект синхронизации, чье состояние является свободным (signalled), когда им не владеет ни один поток, 
в противном случае он считается занятым (mutex signalled). Мьютекс используется для поочередного доступа к разделяемым ресурсам. 
<p align="justify">Поток владеет мьютексом от момента выхода из wait функции до вызова RtReleaseMutex. Ни один другой поток не может 
владеть мьютексом в этом промежутке. Если другой поток вызывает wait функцию в то время, когда мьютекс занят (not signalled), 
wait функция не вернет управление до тех пор, пока владелец мьютекса его не освободит. Когда владеющий поток заканчивает 
исполнение, мьютекс переходит в свободное состояние и теряет владельца. Ожидающий поток узнает об “осиротевшем” мьютексе 
по результату, возвращаемому wait функцией.
<p>Если более одного потока ждут мьютекс, то владение мьютексом получит поток с максимальным приоритетом и он же первым 
получит управление от wait функции.
<p>Если мьютекс ждут процессы с одинаковым приоритетом, управление получит поток, запросивший владение раньше других. 
<p>Мьютекс, по сути, является упрощенной формой семафора. Принципиальным отличием мьютекса от семафора 
является возможность повторного занятия мьютекса одной и той же нитью.
<p>Мьютексы и семафоры порождаются с помощью функций CreateMutex и CreateSemaphore. Для занятия мьютекса или семафора 
используется любая из группы WaitFor-функций. Для освобождения объектов используются соответственно функции ReleaseMutex 
и ReleaseSemaphore. Поток, которому заведомо известно, что семафор уже создан, может не создавать семафор, а открыть его с помощью функции OpenSemaphore.<br>
<p><u>Описание функции  CreateSemaphore:</u>
<p>WINBASEAPI<br>
&nbsp;&nbsp;&nbsp;&nbsp;HANDLE<br>
 &nbsp;&nbsp;&nbsp;&nbsp; WINAPI<br>
&nbsp;&nbsp;&nbsp;&nbsp;CreateSemaphoreA(<br>
&nbsp;&nbsp;&nbsp;&nbsp;LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,<br>
&nbsp;&nbsp;&nbsp;&nbsp;LONG lInitialCount,<br>
&nbsp;&nbsp;&nbsp;&nbsp;LONG lMaximumCount,<br>
&nbsp;&nbsp;&nbsp;&nbsp;LPCSTR lpName<br>
&nbsp;&nbsp;&nbsp;&nbsp;);<br>
&nbsp;&nbsp;&nbsp;&nbsp;WINBASEAPI<br>
&nbsp;&nbsp;&nbsp;&nbsp;HANDLE<br>
&nbsp;&nbsp;&nbsp;&nbsp;WINAPI<br>
&nbsp;&nbsp;&nbsp;&nbsp;CreateSemaphoreW(<br>
&nbsp;&nbsp;&nbsp;&nbsp;LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,<br>
&nbsp;&nbsp;&nbsp;&nbsp;LONG lInitialCount,<br>
&nbsp;&nbsp;&nbsp;&nbsp;LONG lMaximumCount,<br>
&nbsp;&nbsp;&nbsp;&nbsp;LPCWSTR lpName<br>
&nbsp;&nbsp;&nbsp;&nbsp;);<br>
&nbsp;&nbsp;&nbsp;&nbsp;#ifdef UNICODE<br>
&nbsp;&nbsp;&nbsp;&nbsp;#define CreateSemaphore  CreateSemaphoreW<br>
&nbsp;&nbsp;&nbsp;&nbsp;#else<br>
&nbsp;&nbsp;&nbsp;&nbsp;#define CreateSemaphore  CreateSemaphoreA<br>
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;#endif // !UNICODE
<p>Первый  аргумент, что и следует из его типа, является указателем на структуру,  содержащую атрибуты доступа к семафору. Он может также принимать значение NULL в том случае, если эти атрибуты не использу­ются, как,  например, в Windows'95.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Второй  аргумент - начальное значение счетчика учета ресурсов. Этот аргумент  определяет, сколько потоков может получить доступ к ресурсам в момент вызова  функции. К примеру, компьютер имеет три порта, к которым обращается программа.  В этом случае значение счетчика учета ресурсов может быть в пределах от 0 (нет  свободных портов) до трех (все порты свободны). При обращении потока к ресурсу  система проверяет, свободен ли ресурс, т. е. не установлено ли максимальное  значение счетчика учета ресурсов (третий аргумент функции), после чего разрешает  или запрещает доступ к ресурсу. Если для потока ресурсы недоступны, то он будет  ждать освобождения ресурсов.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Последний,  четвертый аргумент, - это указатель на строку, содержащую имя семафора.<br>
&nbsp;&nbsp;&nbsp;&nbsp;При успешном завершении функция возвращает хэндл созданного семафора.,  то она возвращает хэндл открытого семафора.
<p><u>Описание функции ReleaseSemaphore: </u>
<p>WINBASEAPI<br>
  &nbsp;&nbsp;&nbsp;&nbsp;BOOL<br>
  &nbsp;&nbsp;&nbsp;&nbsp;WINAPI<br>
  &nbsp;&nbsp;&nbsp;&nbsp;ReleaseSemaphore(<br>
&nbsp;&nbsp;&nbsp;&nbsp;HANDLE hSemaphore,<br>
&nbsp;&nbsp;&nbsp;&nbsp;LONG lReleaseCount,<br>
&nbsp;&nbsp;&nbsp;&nbsp;LPLONG lpPreviousCount<br>
&nbsp;&nbsp;&nbsp;&nbsp;);
<p>Первый аргумент - это хэндл семафора, полученный с помощью функции  CreateSemaphore(). Второй  аргумент определяет, какое значение должно быть установлено в счетчике ресурсов семафора при его  освобождении. В двойное слово, адрес которого определяется третьим аргументом,  записывается предыдущее значение счетчика.
<p><u>Описание функции OpenSemaphore: </u>
<p>
  WINBASEAPI HANDLE WINAPI OpenSemaphoreA<br>
    &nbsp;&nbsp;&nbsp;&nbsp;(<br>
    &nbsp;&nbsp;&nbsp;&nbsp;DWORD dwDesiredAccess,<br>
    &nbsp;&nbsp;&nbsp;&nbsp;BOOL bInheritHandle,<br>
    &nbsp;&nbsp;&nbsp;&nbsp;LPCSTR lpName<br>
    &nbsp;&nbsp;&nbsp;&nbsp;);<br>
    &nbsp;&nbsp;&nbsp;&nbsp;WINBASEAPI HANDLE WINAPI OpenSemaphoreW<br>
    &nbsp;&nbsp;&nbsp;&nbsp;(<br>
    &nbsp;&nbsp;&nbsp;&nbsp;DWORD dwDesiredAccess,<br>
    &nbsp;&nbsp;&nbsp;&nbsp;BOOL bInheritHandle,<br>
    &nbsp;&nbsp;&nbsp;&nbsp;LPCWSTR ipName);<br>
    &nbsp;&nbsp;&nbsp;&nbsp;#ifdef UNICODE<br>
    &nbsp;&nbsp;&nbsp;&nbsp;#define OpenSemaphore OpenSemaphoreW<br>
    &nbsp;&nbsp;&nbsp;&nbsp;#else<br>
    &nbsp;&nbsp;&nbsp;&nbsp;#define OpenSemaphore OpenSemaphoreA<br>
    &nbsp;&nbsp;&nbsp;&nbsp;#endif// UNICODE 
<p align="justify">Первый аргумент  определяет уровень доступа к семафору.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Второй аргумент  определяет, наследуют ли этот семафор другие процессы, создаваемые функцией CreateProcess(). Значение TRUE говорит о том, что семафор является наследуемым.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Главным  аргументом в этой функции является третий аргумент, определяющий имя  открываемого семафора. Если функция выполняется успешно, то она возвращает  хэндл открытого семафора.
<p>&nbsp;Критической секцией называется участок кода, в котором поток получает доступ к разделяемому ресурсу (обычно некоторая переменная), доступному другим потокам. Критическую секцию имеет смысл создавать, если она будет использоваться не менее двух раз — тогда, когда доступ к одному и тому же ресурсу одновременно требуется разным потокам.<BR>
  &nbsp;&nbsp;&nbsp;Объект "критическая секция" обеспечивает синхронизацию так же, как и объект "взаимоисключение" (см. ниже), однако он может использоваться
  лишь в рамках одного процесса. Использование критических секций обеспечивает немного более быстрый и более эффективный механизм синхронизации. Как и взаимоисключением, объектом "критическая секция" одновре¬менно владеет только один поток, что обеспечивает защиту разделяемого ресурса.
  Win32 API поддерживает специальный тип данных для критических секций — CRITICALSECTION, две функции для их создания и удаления и две функции для их использования.<BR>
  CRITICAL_SECTION section;<BR>
  Функция InitializeCriticalSection используется для инициализации объекта "критическая секция".
<p> VOID lnitializeCriticalSection(LPCRITICAL_SECTION IpCriticalSection);
<p> IpCriticalSection — адрес переменной типа CRITICALSECTION.
<p> Функция DeleteCriticalSection используется для освобождения объекта "критическая секция".
<p> VOID DeleteCriticalSection(LPCRITICAL_SECTION IpCriticalSection);
<p> IpCriticalSection— адрес переменной типа CRITICAL_SECTION.
<p> Функция EnterCriticalSection используется для запроса на вход в критическую секцию.
<p> VOID EnterCriticalSection(LPCRITICAL_SECTION IpCriticalSection);
<p> IpCriticalSection — адрес переменной типа CRITICAL_SECTION.
<p> Функция LeaveCriticalSection используется для уведомления о выходе из критической секции.
<p> VOID LeaveCriticalSection(LPCRITICAL_SECTION IpCriticalSection);
<p> IpCriticalSection - адрес переменной типа CRITICAL_SECTION.
<p> Для использования критической секции достаточно создать переменную типа CRITICALSECTION, а перед использованием проинициализировать ее с помощью функции InitializeCriticalSection. Для запроса входа в критическую секцию поток должен вызывать функцию EnterCriticalSection, а по завершении — функцию LeaveCriticalSection. Если другой процесс находится в своем критическом участке кода, то вызов функции EnterCriticalSection вызовет блокировку потока до тех пор, пока другой процесс не покинет свой критический участок. <BR>
  <BR>
  <A name=control></A>
<P><b><U>Контрольные вопросы</U></b><BR><BR></P>
<I><OL type=1 start=1>
<B>
<LI>Чем отличаются синхронные и асинхронные операции?
<LI>Что такое разделяемая память?
<LI>Чем мьютекс отличается от семафора?
<LI>Как с помощью семафоров обеспечить множественный доступ нитей к ресурсу?
<LI>Почему мьютексы облегчают написание рекурсивных функций с доступом к критическому ресурсу по сравнению с семафорами?
</B>
</OL></I>

<BR><BR>
<A name=task></A>
<P><b><U>Задания</U></b><BR><BR></P>
<OL type=1 start=1><I><B>
<LI>Разработать программу, копирующую содержимое одного каталога в другой. Операции копирования файлов должны выполняться 
одной нитью в асинхронном режиме.
<LI>Разработать программу, осуществляющую подсчет количества символов латинского алфавита в файле. Чтение файла должно 
осуществляться параллельно подсчету. Процесс программы должен состоять из одной нити.
<LI>Разработать программу копирования больших файлов 64 килобайтными блоками. Операции чтения и записи должны производиться 
одной нитью в асинхронном режиме одновременно.
<LI>Разработать менеджер копирования файлов, позволяющий прервать текущую операцию копирования по запросу пользователя.
<LI>Разработать менеджер копирования файлов, выполняющий операции копирования в фоновом режиме с помощью одной нити.
<LI>Разработать программу, позволяющую выполнять одновременно до трех файловых операций в асинхронном режиме, используя 
три предварительно созданных события. Каждая следующая файловая операция должна работать с одним из свободных событий. 
Если все события заняты, то необходимо дождаться освобождения любого из них.
<LI>Разработать менеджер копирования файлов, состоящий из двух нитей. Одна нить должна инициировать операцию копирования, 
а вторая нить уведомлять о завершении операции.
<LI>Разработать программу, осуществляющую подсчет числа строк в текстовом файле. Чтение файла должно осуществляться 
параллельно подсчету. Процесс программы должен состоять из одной нити.
<LI>Разработать программу поиска всех файлов в каталоге «c:\». По каждому найденному файлу должна быть сделана запись 
в файле лога с помощью асинхронного режима записи.
<LI>Разработать программу, осуществляющую подсчет количества символов русского алфавита в файле. Чтение файла должно 
осуществляться параллельно подсчету. Процесс программы должен состоять из одной нити.
<LI>Разработать программу, осуществляющую подсчет числа слов в текстовом файле. Чтение файла должно осуществляться 
параллельно подсчету. Процесс программы должен состоять из одной нити.
<LI>Разработать менеджер резервного копирования файлов, копирующий в асинхронном режиме содержимое заданного каталога.
<LI>Имеется 3 процесса. Два из них производят инкремент переменной в разделяемой памяти на 1. Одна – декремент на 2. 
Работа с переменной должна осуществляться с помощью критической секции на основе мьютексов. Вывести на экран текущее 
значение переменной и крайние значения.
<LI>Имеется 3 процесса. Два из них производят инкремент переменной в разделяемой памяти на 1. Одна – декремент на 2. 
Работа с переменной должна осуществляться с помощью критической секции на основе семафоров. Вывести на экран текущее 
значение переменной и крайние значения.
<LI>Разработать программу, показывающую текущее количество запущенных экземпляров этой программы.
<LI>Разработать программу, передающую текстовые сообщения между двумя запущенными экземплярами программы в любом направлении 
с помощью буфера, расположенного в разделяемой памяти. Синхронизация с использованием семафоров.
<LI>Разработать программу, передающую текстовые сообщения между двумя запущенными экземплярами программы в любом направлении 
с помощью буфера, расположенного в разделяемой памяти. Синхронизация с использованием мьютексов.
<LI>Разработать программу, показывающую количество запусков этой программы, пока хотя бы один экземпляр программы находится в памяти.
<LI>Имеется 2 клиента и 1 сервер. Необходимо осуществлять передачу данных от клиентов к серверу через один и тот же буфер в 
разделяемой памяти. Синхронизация с использованием семафоров.
<LI>Имеется 2 клиента и 1 сервер. Необходимо осуществлять передачу данных от клиентов к серверу через один и тот же буфер в 
разделяемой памяти. Синхронизация с использованием мьютексов.
<LI>Разработать программу, синхронизирующую информацию на консольных экранах для двух своих запусков с помощью буфера в 
разделяемой памяти. Синхронизация с использованием семафоров.
<LI>Разработать программу, синхронизирующую информацию на консольных экранах для двух своих запусков с помощью буфера в 
разделяемой памяти. Синхронизация с использованием мьютексов.
<LI>Разработать систему из двух программ. Первая программа предназначена для ввода команд DOS. Вторая программа 
демонстрирует результаты выполнения команд. Синхронизация с использованием семафоров.
<LI>Разработать систему из двух программ. Первая программа предназначена для ввода команд DOS. Вторая программа 
демонстрирует результаты выполнения команд. Синхронизация с использованием мьютексов.
</B></OL></I>

</body>

</html>
