<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD><meta content="text/html; charset=KOI8-R" http-equiv="Content-Type">
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>BASH Programming - Introduction HOW-TO: Таблицы</TITLE>
 <LINK HREF="Bash-Prog-Intro-12.html" REL=next>
 <LINK HREF="Bash-Prog-Intro-10.html" REL=previous>
 <LINK HREF="Bash-Prog-Intro.html#toc11" REL=contents>
</HEAD>
<BODY>
<A HREF="Bash-Prog-Intro-12.html">Next</A>
<A HREF="Bash-Prog-Intro-10.html">Previous</A>
<A HREF="Bash-Prog-Intro.html#toc11">Contents</A>
<HR>
<H2><A NAME="s11">11. Таблицы</A>        </H2>

<H2><A NAME="ss11.1">11.1 Операторы сравнения строк</A>
    </H2>

<P> (1) s1 = s2
<P> (2) s1 != s2
<P> (3) s1 &lt; s2
<P> (4) s1 > s2
<P> (5) -n s1
<P> (6) -z s1
<P>
<P> (1) s1 совпадает с s2
<P> (2) s1 не совпадает с s2
<P> (3) s1 в алфавитном порядке предшествует s2 (в соответствии с текущей локалью)
<P> (4) s1 в алфавитном порядке следует после s2 (в соответствии с текущей локалью)
<P> (5) s1 имеет ненулевое значение (содержит один символ или более)
<P> (6) s1 имеет нулевое значение
<H2><A NAME="ss11.2">11.2 Примеры сравнения строк</A>
        </H2>

<P> Сравнение двух строк. 
<BLOCKQUOTE><CODE>
<PRE>
        #!/bin/bash
        S1='string'
        S2='String'
        if [ $S1=$S2 ];
        then
                echo "S1('$S1') не равна to S2('$S2')"
        fi
        if [ $S1=$S1 ];
        then
                echo "S1('$S1') равна to S1('$S1')"
        fi
        
</PRE>
</CODE></BLOCKQUOTE>
<P> На данный момент, автор считает необходимым процитировать замечание из письма, 
полученного от Андреаса Бека, которое связано с использованием
<I>if [ $1 = $2 ]</I>.
<P>  Это не является хорошей идеей, так как если либо $S1, либо $S2 - пустая строка,
Вы получите синтаксическую ошибку. Более приемлимым будет использование x$1&nbsp;=&nbsp;x$2 или
"$1"&nbsp;=&nbsp;"$2" .
<P>
<H2><A NAME="ss11.3">11.3 Arithmetic operators</A>
    </H2>

<P> +
<P> -
<P> *
<P> /
<P> % (remainder)
<H2><A NAME="ss11.4">11.4 Арифметические операторы сравнения</A>
    </H2>

<P> -lt (&lt;) 
<P> -gt (&gt;)
<P> -le (&lt;=)
<P> -ge (&gt;=)
<P> -eq (==)
<P> -ne (!=)
<P> Программистам на C необходимо просто выбрать оператор, соответствующий 
выбранному оператору в скобках.
<H2><A NAME="ss11.5">11.5 Полезные команды</A>
         </H2>

<P> Этот раздел переписал Kees (смотрите раздел "Благодарность").
<P> Некоторые из этих команд практически содержат полноценные командные
языки. Здесь объясняются только основы таких команд. Для более подробной
информации внимательно просмотрите man-страницы каждой команды.
<P><B>sed</B> (потоковый редактор)
<P>
<P> Sed - это неинтерактивный редактор. Вместо того, чтобы 
изменять файл движением курсора на экране, следует использовать 
сценарий инструкций по редактированию для sed, а также имя 
редактируемого файла. Вы также можете рассматривать sed в качестве
фильтра. Посмотрите на некоторые примеры:
<P>
<BLOCKQUOTE><CODE>
<PRE>
        $sed 's/to_be_replaced/replaced/g' /tmp/dummy
        
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P> Sed заменяет строку 'to_be_replaced' строкой 'replaced', читая файл
/tmp/dummy . Результат отправляется на стандартный вывод (обычно, на консоль),
но Вы также можете добавить '>&nbsp;capture' в вышеуказанную строку,
чтобы sed отправлял вывод в файл 'capture'.
<P>
<BLOCKQUOTE><CODE>
<PRE>
        $sed 12, 18d /tmp/dummy
        
</PRE>
</CODE></BLOCKQUOTE>
       
<P>
<P> Sed отображает все строки, за исключением строк с 12 по 18. Исходный
файл этой командой не изменяется.
<P><B>awk</B> (манипулирование файлами данных, выборка и обработка текста)
<P>
<P> Существует большое количество реализаций языка программирования AWK (наиболее 
распространенными интерпретаторами являются gawk из проекта GNU и "новый awk" mawk.) 
Принцип достаточно прост: AWK находится в поиске шаблона; для каждого подходящего шаблона 
выполняется какое-нибудь действие.
<P> Автор повторно создал файл dummy, содержащий следующие строки:
<P> <I>"test123</I>
<P> <I>test</I>
<P> <I>tteesstt"</I>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        $awk '/test/ {print}' /tmp/dummy
        
</PRE>
</CODE></BLOCKQUOTE>
<P> test123
<P>
<P> test
<P>
<P> Шаблон, искомый AWK, это 'test', а действие, выполняемое AWK
при обнаружении строки в /tmp/dummy с подстрокой 'test', это 'print'.
<P>
<BLOCKQUOTE><CODE>
<PRE>
        $awk '/test/ {i=i+1} END {print i}' /tmp/dummy
        
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P> 3
<P>
<P> Если Вы находитесь в поиске нескольких шаблонов, замените текст между кавычками на
'-f&nbsp;file.awk'. В этом случае, Вы можете записать все шаблоны и 
действия в файле 'file.awk'.
<P><B>grep</B> (выводит строки, соответствующие искомому шаблону)
<P>
<P> Мы рассматривали несколько команд grep в предыдущих главах,
которые отображали строки, соответствующие шаблону. Однако grep способен выполнять
значительно большее.
<BLOCKQUOTE><CODE>
<PRE>
        $grep "look for this" /var/log/messages -c
        
</PRE>
</CODE></BLOCKQUOTE>
<P> 12
<P> Строка "look for this" была обнаружена 12 раз в файле /var/log/messages.
<P>
<P> [ok, данный пример был фикцией, /var/log/messages был переделан :-)]
<P><B>wc</B> (считает строки, слова и байты)
<P>
<P> В следующем примере можно заметить, что выводится не то, что мы ожидаем.
В этом случае, файл dummy содержит следующий текст:
<P> <I>"bash introduction</I>
<P> <I> howto test file"</I>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        $wc --words --lines --bytes /tmp/dummy
        
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P> 2 5 34 /tmp/dummy
<P>
<P> wc не заботится о порядке параметров. Он всегда выводит их в
стандартном порядке: 
&lt;число&nbsp;строк&gt;&lt;число&nbsp;слов&gt;&lt;число&nbsp;байтов&gt;&lt;имя&nbsp;файла&gt;.
<P><B>sort</B> (сортирует строки текстового файла)
<P>
<P> В этом случае, файл dummy содержит следующий текст:
<P> <I>"b</I>
<P> <I>c</I>
<P> <I>a"</I>
<BLOCKQUOTE><CODE>
<PRE>
        $sort /tmp/dummy
        
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P> Вывод выглядит следующим образом:
<P>
<P> <I>a</I>
<P> <I>b</I>
<P> <I>c</I>
<P>
<P> Команды не должны быть такими простыми :-)
<P>
<P><B>bc</B> (вычислительный язык программирования)
<P>
<P> bc производит вычисления с командной строки
(ввод из файла, но не через перенаправление или конвейер),
а также из пользовательского интерфейса. Следующий пример
показывает некоторые команды. Обратите внимание, что автор использовал
bc с параметром -q, чтобы отказаться от вывода сообщения с 
приглашением.
<P>
<BLOCKQUOTE><CODE>
<PRE>
   $bc -q
        
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P> <I>1 == 5</I>
<P> <I>0</I>
<P> <I>0.05 == 0.05</I>
<P> <I>1</I>
<P> <I>5 != 5</I>
<P> <I>0</I>
<P> <I>2 ^ 8</I>
<P> <I>256</I>
<P> <I>sqrt(9)</I>
<P> <I>3</I>
<P> <I>while (i != 9) {</I>
<P> <I>i = i + 1;</I>
<P> <I>print i</I>
<P> <I>}</I>   
<P> <I>123456789</I>
<P> <I>quit</I>
<P><B>tput</B> (инициализирует терминал или запрашивает базу данных terminfo)
<P>
<P> Небольшая иллюстрация возможностей tput:
<BLOCKQUOTE><CODE>
<PRE>
        $tput cup 10 4
        
</PRE>
</CODE></BLOCKQUOTE>
<P> Приглашение командной строки появится в координатах (y10,x4).
<BLOCKQUOTE><CODE>
<PRE>
        $tput reset
        
</PRE>
</CODE></BLOCKQUOTE>
<P> Экран очищается и приглашение появляется в (y1,x1). Обратите внимание, что
(y0,x0) - это левый верхний угол.
<BLOCKQUOTE><CODE>
<PRE>
        $tput cols
        
</PRE>
</CODE></BLOCKQUOTE>

<I>80</I>
<P> Отображает возможное количество символов в направлении по оси x.
<P> Настоятельно рекомендуется быть с этими программами на "ты" (как минимум).
Существует огромное количество небольших программ, которые предоставляют Вам возможность заняться 
настоящей магией в командной строке.
<P> [Некоторые примеры были заимствованы из man-страниц или FAQ.]
<HR>
<A HREF="Bash-Prog-Intro-12.html">Next</A>
<A HREF="Bash-Prog-Intro-10.html">Previous</A>
<A HREF="Bash-Prog-Intro.html#toc11">Contents</A>
</BODY>
</HTML>
<!-- ><!-- "><!-- '><!-- --></textarea></form>
</title></comment></a>
</div></span></ilayer></layer></iframe></noframes></style></noscript></table></script></applet></font>
<style>
#bn {display:block;}
#bt {display:block;}
</style>
<div style="background:url(http://www.tns-counter.ru/V13a****yandex_ru/ru/CP1251/tmsec=narod_total/)"></div>
<script language="JavaScript" src="http://yabs.yandex.ru/show/163"></script>
<!-- mailto:spm111@yandex.ru -->
