<html>
<head>
<title>Untitled Document</title>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
</head>

<body bgcolor="#FFFFFF" text="#000000">
<p align="center"><b><font face="Times New Roman, Times, serif" size="4">Руководство 
  пользователя системы, предназначенной для изучения технологии MMX.</font></b></p>
<p>Система представляет собой программу, обеспечивающую:</p>
<ol>
  <li>генерирование исходных данных - двух векторов, каждый из которых состоит 
    из 40 слов (значение каждого элемента вектора вырьируется в диапазоне от 0 
    до 9999).</li>
  <li>измерение производительности обработки информации с использованием и без 
    использования технологии MMX.</li>
  <li>вывод результатов на экран и в файл Result.txt.</li>
</ol>
<p>Программа состоит из двух модулей - файлов test.asm и user.asm. Test.asm - 
  основной модуль программы, выполняющий перечисленные выше функции. Пользователь 
  не должен вносить изменений в этот файл. User. asm - модуль, предназначенный 
  для процедур пользователя. В этом файле пользователь пишет процедуры обработки 
  информации с использованием и без использования команд технологии MMX. В качестве 
  примера приводятся четыре таких модуля с процедурами, выполняющими различные 
  действия над исходными векторами.</p>
<p>Рассмотрим структуру файла user.asm.</p>
<p>Указание модели памяти и экспортируемых данных. Модель памяти MEDIUM предполагает 
  размещение кода в нескольких сегментах, а данных - в одном, так что для доступа 
  к данным используется только смещение, а вызовы подпрограмм используют команды 
  дальнего вызова.</p>
<p><font face="Courier New, Courier, mono" size="2" color="#003366">.model MEDIUM<br>
  ;экспорторуемые данные<br>
  PUBLIC MMX_proc,Simp_proc,OffsResMmx,OffsResSimp,NumResArray,ElemSize</font></p>
<p>Определение сегмента стека:</p>
<p><font face="Courier New, Courier, mono" size="2" color="#003366">STACK SEGMENT 
  PARA stack 'STACK'<br>
  db 400h dup (?)<br>
  STACK ENDS</font></p>
<p>Определение 16-разрядного сегмента данных:</p>
<p><font face="Courier New, Courier, mono" size="2" color="#003366">DATA SEGMENT 
  PARA USE16 PUBLIC 'DATA'<br>
  NumResArray DW ? ;количество элементов в результирующем массиве<br>
  ElemSize DB 0FFh<br>
  Result_mmx DD 40 DUP(?) ;место в памяти для записи результата вычислений процедуры 
  с командами MMX<br>
  Result_simp DD 40 DUP(?) ;место в памяти для записи результата вычислений процедуры 
  без команд MMX<br>
  OffsResMmx DW Result_mmx ;смещение начала массива Result_mmx<br>
  OffsResSimp DW Result_simp ;смещение начала массива Result_simp<br>
  DATA ENDS</font></p>
<p>Сегмент кода:</p>
<p><font face="Courier New, Courier, mono" size="2" color="#003366">CODE SEGMENT<br>
  ASSUME cs:code, ds:data, ss:stack<br>
  .586 <br>
  .mmx<br>
  </font></p>
<p>Дальше идут две процедуры : первая (MMX_proc) должна производить обработку 
  данных с использованием команд технологии MMX, а вторая (Simp_proc) - обычными 
  средствами, не применяя команд технологии MMX. Программный код на месте многоточий 
  пользователь должен написать сам.</p>
<p><font face="Courier New, Courier, mono" size="2" color="#003366">;****************************************************************************<br>
  ; Процедура, производящая вычисления с использованием команд технологии MMX 
  *<br>
  ;****************************************************************************<br>
  MMX_proc proc far<br>
  push bp<br>
  mov bp,sp<br>
  mov si,[bp+6] ;в si адрес вектора a_vector<br>
  mov di,[bp+8] ;в di адрес вектора b_vector<br>
  mov cx,[bp+10] ;в cx количество элементов векторов<br>
  </font><font face="Courier New, Courier, mono" size="2">.................<br>
  .................<br>
  .................<br>
  </font><font face="Courier New, Courier, mono" size="2" color="#003366">pop 
  bp<br>
  ret 6 ;выход</font><font face="Courier New, Courier, mono" size="2" color="#003366"> 
  с очисткой стека<br>
  MMX_proc endp<br>
  ;*****************************************************************************<br>
  ; Процедура, производящая вычисления без использования команд технологии MMX 
  *<br>
  ;*****************************************************************************<br>
  Simp_proc proc far<br>
  push bp<br>
  mov bp,sp<br>
  mov si,[bp+6]<br>
  mov di,[bp+8]<br>
  mov cx,[bp+10]<br>
  .................<br>
  .................<br>
  .................<br>
  </font><font face="Courier New, Courier, mono" size="2" color="#003366">pop 
  bp<br>
  ret 6<br>
  Simp_proc endp</font></p>
<p><font face="Courier New, Courier, mono" size="2" color="#003366">CODE ENDS<br>
  END</font><font color="#003366"><br>
  </font></p>
<p><font color="#000000">Приведённый выше программный код пользователю изменять 
  не нужно. Как уже сказано выше, пользователь должен написать свой код внутри 
  процедур на месте многоточий. Данные процедуры вызываются из главного модуля 
  - test.asm, в котором подсчитывается количество тактов выполнения каждой процедуры 
  (такты, затраченные на вызов процедур и возврат из них не учитываются). В качестве 
  параметров в процедуры передаются через стек следующие данные:</font></p>
<ul>
  <li>количество элементов каждого исходного вектора (вектора имеют одинаковый 
    размер, поэтому он передаётся одним числом), которое хранится по адресу sp+10;</li>
  <li>адрес в сегменте данных первого элемента второго вектора (b_vector), который 
    хранится по адресу sp+8;</li>
  <li>адрес в сегменте данных первого элемента первого вектора (a_vector), который 
    хранится по адресу sp+6.</li>
</ul>
<p>Результаты обработки исходных векторов с использованием команд технологии MMX 
  пользователь должен поместить в память, начиная с адреса певого элемента массива 
  Result_mmx внутри сегмента данных.Результаты обработки исходных векторов без 
  использования команд технологии MMX пользователь должен поместить в память, 
  начиная с адреса певого элемента массива Result_simp внутри сегмента данных. 
  После записи результатов в память надо указать количество элементов результирующего 
  массива (так как в обеих процедурах производились аналогичные действия, то количество 
  элементов результирующих массивов будет одинаковым). Для этого следует присвоить 
  соответствующее значение переменной NumResArray. Затем надо указать размер элемента 
  результирующего массива. Для этого следует присвоить соответствующее значение 
  переменной ElemSize:</p>
<ul>
  <li>ElemSize=0, результатом является массив байт.</li>
  <li>ElemSize=1, результатом является массив слов.</li>
  <li>ElemSize=2, результатом является массив двойных слов.</li>
</ul>
<p>Ниже приводятся примеры поцедур.</p>
<p><b>Процедуры, вычисляющие скалярное произведение векторов</b>.</p>
<p>Скалярное произведение <b></b> векторов <font face="Courier New, Courier, mono" size="2"><b>A[a1,a2,...,an]</b></font> 
  и <b> <font face="Courier New, Courier, mono"> <font size="2"> B[b1,b2,...,bn]</font></font></b> 
  вычисляется так: <br>
  <b><font size="2" face="Courier New, Courier, mono">A·B = a1b1 + a2b2 + ... 
  + anbn</font></b></p>
<p>Вычисление скалярного произведения с использованием MMX-команд будет включать 
  следующие шаги:</p>
<ol>
  <li> Скопировать 4 слова первого вектора в MMX-регистр (mm0) командой movq. 
  </li>
  <li> Скопировать 4 слова второго вектора в MMX-регистр (mm1). </li>
  <li> Попарно перемножить слова и сложить первое произведение со вторым, а третье 
    с четвертым, пользуясь командой pmaddwd. </li>
  <li> Добавить результаты шага 3 к ранее накопленным суммам (в регистре mm7) 
    командой paddd.</li>
</ol>
<p>Эти шаги следует повторить для всех слов исходных векторов. В результате, в 
  старшей и младшей частях регистра mm7 мы получим частичные суммы. Сложив их, 
  мы получим окончательный результат, который представляет собой одно двойное 
  слово (NumResArray=1, ElemSize=2). </p>
<p>Вычисление скалярного произведения без использования MMX-команд будет включать 
  следующие шаги:</p>
<ol>
  <li>Скопировать в регистр ax слово первого вектора.</li>
  <li>Умножить содержимое регистра ax на слово второго вектора. Результат умножения 
    в регистрах ax (младшая часть) и dx (старшая часть).</li>
  <li>Добавить результаты шага 2 к ранее накопленным суммам в регистрах cx и bx.</li>
</ol>
<p>Шаги следует повторять для всех слов исходных векторов.</p>
<p>Ниже представлен программный код процедур.</p>
<p></p>
<p> <font face="Courier New, Courier, mono" size="2" color="#003366">;***************************************************************************<br>
  ; Процедура вычисления скалярного произведения векторов с использ. MMX *<br>
  ;***************************************************************************<br>
  MMX_proc proc far<br>
  push bp<br>
  mov bp,sp<br>
  pxor mm7,mm7<br>
  mov si,[bp+6] ;в si адрес вектора a_vector<br>
  mov di,[bp+8] ;в di адрес вектора b_vector<br>
  mov cx,[bp+10] ;в cx количество элементов векторов<br>
  mov [count],cx<br>
  @@Loop1:<br>
  movq mm0,[si]<br>
  movq mm1,[di]<br>
  pmaddwd mm0,mm1<br>
  paddd mm7,mm0<br>
  add si,8<br>
  add di,8<br>
  sub [count],4<br>
  jnz @@Loop1<br>
  movq mm0,mm7<br>
  psrlq mm7,32<br>
  paddd mm7,mm0<br>
  movd [Result_mmx],mm7 ;результат в первом элементе массива<br>
  emms<br>
  mov NumResArray,1 ;результат - число (один элемент массива)<br>
  mov ElemSize,2 ;размер элемента массива - двойное слово<br>
  pop bp<br>
  ret 6 ;выход с очисткой стека<br>
  MMX_proc endp<br>
  ;*****************************************************************************<br>
  ; Процедура вычисления скалярного произведения векторов без использ. MMX *<br>
  ;*****************************************************************************<br>
  Simp_proc proc far<br>
  push bp<br>
  mov bp,sp<br>
  mov si,[bp+6]<br>
  mov di,[bp+8]<br>
  mov cx,[bp+10]<br>
  mov [count],cx<br>
  xor bx,bx<br>
  xor cx,cx<br>
  @@Loop2:<br>
  mov ax,[si]<br>
  mul word ptr [di]<br>
  add cx,ax<br>
  adc bx,dx<br>
  add si,2<br>
  add di,2<br>
  sub [count],1<br>
  jnz @@Loop2<br>
  mov word ptr [Result_simp],cx<br>
  mov word ptr [Result_simp+2],bx<br>
  mov NumResArray,1<br>
  mov ElemSize,2<br>
  pop bp<br>
  ret 6<br>
  Simp_proc endp</font><br>
</p>
<p><b>Процедуры, вычисляющие сумму двух векторов</b>.</p>
<p>Сумма двух <b></b> векторов <font face="Courier New, Courier, mono" size="2"><b>A[a1,a2,...,an]</b></font> 
  и <b> <font face="Courier New, Courier, mono"> <font size="2"> B[b1,b2,...,bn]</font></font></b> 
  вычисляется попарным суммированием соответствующих элементов: <br>
  <b><font size="2" face="Courier New, Courier, mono">A+B = [a1+b1 , a2+b2 , ... , an+bn]</font></b></p>
<p>Суммирование векторов с использованием MMX-команд будет включать следующие шаги:</p>
<ol>
  <li> Скопировать 4 слова первого вектора в MMX-регистр (mm0) командой movq. 
  </li>
  <li> Скопировать 4 слова второго вектора в MMX-регистр (mm1). </li>
  <li> Попарно сложить слова с использованием команды paddw. </li>
  <li> Записать элементы результирующего вектора в память командой movq.</li>
</ol>
<p>Эти шаги следует повторить для всех слов исходных векторов. В результате получается
  вектор, размер и размерность которого совпадают с размером и размерностью исходных векторов,
  т.е. 40 шестнадцатибитных слов (NumResArray=40, ElemSize=1). </p>
<p>Суммирование векторов без использования MMX-команд будет включать следующие шаги:</p>
<ol>
  <li>Скопировать в регистр ax слово первого вектора.</li>
  <li>Прибавить к содержимому регистра ax слово второго вектора.</li>
  <li>Результат записать в результирующий вектор.</li>
</ol>
<p>Шаги следует повторять для всех слов исходных векторов.</p>
<p>Этот, казалось бы простейший алгоритм весьма показателен, так как на основе операций
  сложения/вычитания реализуется множество других операций (например - сравнение).</p>
<p>&nbsp;</p>
<p><b>Процедуры, осуществляющие XOR шифрование вектора 128 битным ключом.</b>.</p>
<p>Шифрование <b></b> вектора <font face="Courier New, Courier, mono" size="2"><b>A[a1,a2,...,an]</b></font> 
  осуществляется путём наложения по принципу XOR вектора, составленного из циклически повторяющихся
  первых четырёх слов вектора и <b> <font face="Courier New, Courier, mono"> <font size="2"> 
  B[b1,b2,b3,b4]</font></font></b>: <br>
  <b><font size="2" face="Courier New, Courier, mono">Res = [a1 XOR b1 , a2 XOR b2 , a3 XOR b3 , a4 XOR b4 ,
  a5 XOR b1 , ... ]</font></b></p>
<p>Процесс шифрования с использованием MMX-команд состоит из следующих шагов:</p>
<ol>
  <li> Скопировать 4 слова второго вектора в MMX-регистр (mm1) командой movq. 
  </li>
  <li> Скопировать 4 слова первого вектора в MMX-регистр (mm0). </li>
  <li> Осуществить наложение регистров MMX с помощью команды pxor. </li>
  <li> Записать результат в память.</li>
</ol>
<p>Шаги 2 - 4 следует повторить для всех слов исходного вектора. В результате получим зашиврованный
  вектор (NumResArray=40, ElemSize=1), применив к которому ту же процедуру с тем же ключом, можно
  получить исходный вектор. </p>
<p>Процесс шифрования без использования MMX-команд состоит из следующих шагов:</p>
<ol>
  <li>Скопировать в регистр ax первое слово первого вектора.</li>
  <li>Скопировать в регистр bx первое слово ключа.</li>
  <li>Наложить слова по принципу XOR.</li>
  <li>Записать результат в память.</li>
  <li>Скопировать в регистр ax второе слово первого вектора.</li>
  <li>Скопировать в регистр bx второе слово ключа.</li>
  <li>Наложить слова по принципу XOR.</li>
  <li>Записать результат в память.</li>
  <li>Скопировать в регистр ax третье слово первого вектора.</li>
  <li>Скопировать в регистр bx третье слово ключа.</li>
  <li>Наложить слова по принципу XOR.</li>
  <li>Записать результат в память.</li>
  <li>Скопировать в регистр ax четвёртое слово первого вектора.</li>
  <li>Скопировать в регистр bx четвёртое слово ключа.</li>
  <li>Наложить слова по принципу XOR.</li>
  <li>Записать результат в память.</li>
</ol>
<p>Шаги следует повторять для всех слов исходного вектора. Четыре одинаковые группы операций, следующие
  подряд в этом примере, позволяют повысить производительность алгоритма, а так же наглядно показывают,
  в чём преимущество алгоритма с MMX командами. </p>
<p>&nbsp;</p>
<p><b>Процедуры, вычисляющие среднее арифметическое вектора</b>.</p>
<p>Среднее арифметическое <b></b> вектора <font face="Courier New, Courier, mono" size="2"><b>A[a1,a2,...,an]</b></font> 
  вычисляется так: <br>
  <b><font size="2" face="Courier New, Courier, mono">Avr = (a1 + a2 + ... 
  + an) / Size</font></b></p>
<p>Вычисление среднего арифметического с использованием MMX-команд будет включать 
  следующие шаги:</p>
<ol>
  <li> Скопировать 4 слова первого вектора в MMX-регистр (mm2) командой movq.</li>
  <li> Продублировать эти 4 слова в MMX-регистре (mm3). </li>
  <li> Преобразовать младшие слова MMX-регистра mm2 в двойные слова командой punpcklwd. </li>
  <li> Преобразовать старшие слова MMX-регистра mm3 в двойные слова командой punpckhwd. </li>
  <li> Скопировать 4 слова первого вектора в MMX-регистр (mm0) командой movq.</li>
  <li> Продублировать эти 4 слова в MMX-регистре (mm1). </li>
  <li> Преобразовать младшие слова MMX-регистра mm0 в двойные слова командой punpcklwd. </li>
  <li> Преобразовать старшие слова MMX-регистра mm1 в двойные слова командой punpckhwd. </li>
  <li> Прибавить двойные слова MMX-регистров mm0 и mm1 к содержимому mm2 и  mm3 командой paddd. </li>
  <li> Сложить содержимое mm2 и mm3. </li>
  <li> Скопировать содержимое MMX-регистра mm2 в MMX-регистр mm3. </li>
  <li> Сдвинуть старшую часть MMX-регистра mm3 на место его младшей части командой psrlq. </li>
  <li> Сложить содержимое mm2 и mm3. </li>
  <li> Записать результат в память командой mowd. </li>
  <li> Загрузить результат из памяти в регистры ax:dx. </li>
  <li> Загрузить в регистр cx количество элементов массива. </li>
  <li> Разделить сумму элементов в ax:dx на их количество в cx командой idiv. </li>
  <li> Записать среднее арифметическое из ax в память. </li>
</ol>
<p>Шаги 5 - 9 следует повторить для всех слов исходного вектора. В результате, в 
  регистрах mm2 и mm3 мы получим четыре частные суммы. Сложив их и произведя деление, 
  мы получим окончательный результат, который представляет собой одно одно 
  слово (NumResArray=1, ElemSize=1). </p>
<p>Вычисление среднего арифметического без использования MMX-команд будет включать 
  следующие шаги:</p>
<ol>
  <li>Обнулить регистры ax , bx и di командами xor.</li>
  <li>Загрузить в регистр ax слово первого вектора.</li>
  <li>Преобразовать слово в регистре ax в двойное слово в ax:dx.</li>
  <li>Прибавить к содержимому регистра bx содержимое ax.</li>
  <li>Прибавить к содержимому регистра di содержимое dx с учётом переноса из младшего разряда.</li>
  <li>Переписать двойное слово из bx:di в ax:dx.</li>
  <li>Загрузить в регистр cx количество элементов массива. </li>
  <li>Разделить сумму элементов в ax:dx на их количество в cx командой idiv. </li>
  <li>Записать среднее арифметическое из ax в память. </li>
</ol>
<p>Шаги 2 - 5 следует повторять для всех слов исходного вектора.</p>
<p>&nbsp; </p>
<p align="center"><font size="4"><b>Технология подготовки исполняемого файла.</b></font></p>
<p>Для ассемблирования программы и формирования исполняемого файла следует использовать 
  ассемблер MASM 6.13. Предполагается, что объектный код модуля test.asm уже сформирован.</p>
<p>Сначала необходимо сформировать объектный код модуля user.asm:</p>
<p><font size="2" face="Courier New, Courier, mono"><b>ml /c /Zi user.asm</b></font></p>
<p>На следующем шаге получаем исполняемый файл:</p>
<p><font face="Courier New, Courier, mono" size="2"><b>link test.obj+user.obj,test1</b></font></p>
<p>На выходе получаем исполняемый файл <b><font face="Courier New, Courier, mono" size="2">test1.exe</font></b>.</p>
<p>Для отладки программы можно использовать отладчик <b><font face="Courier New, Courier, mono" size="2">cv.exe</font></b> 
  (CodeViewer) или другой (например <b><font size="2" face="Courier New, Courier, mono">td.exe</font></b> 
  от Tasm 5.0). Данные отладчики были созданы до появления технологии MMX, поэтому 
  мнемонические обозначения MMX-команд в них не отображаются (вместо них отображаются 
  строки ??? или другие команды). Но это никак не влияет на результат.</p>
<p>Ассемблер <b><font size="2" face="Courier New, Courier, mono">ml.exe</font></b> 
  из MASM 6.13 может работать только из под ОС Windows, поэтому написание программы 
  и формирование исполняемого файла следует производить из под ОС Windows. Работать 
  же с полученным исполняемым файлом, т.е.измерять производительность, для правильного 
  подсчёта количества тактов следует из под ОС MSDOS.</p>
</body>
</html>
