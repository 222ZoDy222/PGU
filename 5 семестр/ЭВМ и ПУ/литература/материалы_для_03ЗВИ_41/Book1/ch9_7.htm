<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
<TITLE>Защищённый режим процессоров Intel 80286/80386/80486</TITLE>

<META NAME="GENERATOR" CONTENT="Internet Assistant for Microsoft Word 2.04z">
</HEAD>
<BODY BGCOLOR="#ffffff">
<TABLE>
<TR>
<TD><A href="index.htm" tppabs="http://protectmode.narod.ru/index.htm">к содержанию</A></TD>
<TD>
</TR>
</TABLE>
<H2><A NAME="ch9_7">9.7. Недокументированная команда LOADALL</A>
</H2>
<P>
Оказывается, для процессора i80286 существует способ получения
доступа к расширенной памяти, не переключаясь в защищённый режим.
Для этого может быть использована недокументированная команда
LOADALL, имеющая код 0F05h (команда не имеет операндов). Эта команда
не описана в справочниках по процессору i80286, информация о ней
поставляется фирмой Intel по запросу. Те сведения о команде LOADALL,
которые приведены в нашей книге, получены по электронной почте
из BBS и могут быть использованы только для расширения вашего
кругозора и для оценки полезности этой команды в ваших разработках.
<P>
Команда LOADALL первоначально была задумана фирмой Intel как тестовая.
Однако оказалось, что она пригодна и для обращения к расширенной
памяти в реальном режиме. Широко известный драйвер расширенной
памяти HIMEM.SYS обращается в область адресов выше первого мегабайта
именно с помощью команды LOADALL (а не переключаясь в защищённый
режим и возвращаясь обратно, как это можно было бы предположить).
<P>
Команда LOADALL сокращает время, требуемое драйверу HIMEM.SYS
на доступ к расширенной памяти, так как время на переключение
в защищённый режим и обратное переключение достаточно велико по
сравнению с временем, необходимым на копирование данных из основной
памяти в расширенную или обратно.
<P>
Другое применение команды - драйвер электронного диска Microsoft
RAMDRIVE.SYS и блок совместимости операционной системы Microsoft
OS/2 версии 1.x.
<P>
Секрет команды LOADALL заключается в том, что она загружает ВСЕ
регистры процессора, и может выполняться в реальном режиме. Изменяя
поле базы регистра кэша дескриптора (внутренний системный регистр
процессора) программа может обратиться к сегменту, лежащему за
пределами первого мегабайта адресного пространства.
<P>
Как мы уже говорили, команда LOADALL не имеет операндов. Регистры
загружаются из буфера, который имеет длину 102 байта и должен
быть подготовлен в области памяти с физическим адресом 00800h.
<P>
Формат буфера представлен в следующей таблице:<BR>
<P>
Таблица 16. Формат буфера для команды LOADALL.
<P>
<TABLE BORDER=1>
<TR><TD WIDTH=102>Адрес</TD><TD WIDTH=466>Регистры процессора
</TD></TR>
<TR><TD WIDTH=102>800h-805h</TD><TD WIDTH=466>Не используется
</TD></TR>
<TR><TD WIDTH=102>806h-807h</TD><TD WIDTH=466>Слово состояния процессора MSW (Machine Status Word)
</TD></TR>
<TR><TD WIDTH=102>808h-815h</TD><TD WIDTH=466>Не используется
</TD></TR>
<TR><TD WIDTH=102>816h-817h</TD><TD WIDTH=466>Регистр задачи TR (Task Register)
</TD></TR>
<TR><TD WIDTH=102>818h-819h</TD><TD WIDTH=466>Регистр флагов</TD>
</TR>
<TR><TD WIDTH=102>81Ah-81Bh</TD><TD WIDTH=466>Регистр IP (Instruction Pointer)
</TD></TR>
<TR><TD WIDTH=102>81Ch-81Dh</TD><TD WIDTH=466>Селектор LDT (Local Descriptor Table)
</TD></TR>
<TR><TD WIDTH=102>81Eh-81Fh</TD><TD WIDTH=466>Регистр DS (Data Segment Selector)
</TD></TR>
<TR><TD WIDTH=102>820h-821h</TD><TD WIDTH=466>Регистр SS (Stack Segment Selector)
</TD></TR>
<TR><TD WIDTH=102>822h-823h</TD><TD WIDTH=466>Регистр CS (Code Segment Selector)
</TD></TR>
<TR><TD WIDTH=102>824h-825h</TD><TD WIDTH=466>Регистр ES (Extra Segment Selector)
</TD></TR>
<TR><TD WIDTH=102>826h-827h</TD><TD WIDTH=466>Регистр DI (Destination Index)
</TD></TR>
<TR><TD WIDTH=102>818h-829h</TD><TD WIDTH=466>Регистр SI (Source Index)
</TD></TR>
<TR><TD WIDTH=102>82Ah-82Bh</TD><TD WIDTH=466>Регистр BP (Base Pointer)
</TD></TR>
<TR><TD WIDTH=102>82Ch-82Dh</TD><TD WIDTH=466>Регистр SP (Stack Pointer)
</TD></TR>
<TR><TD WIDTH=102>82Eh-82Fh</TD><TD WIDTH=466>Регистр BX (Data Register BX)
</TD></TR>
<TR><TD WIDTH=102>830h-831h</TD><TD WIDTH=466>Регистр DX (Data Register DX)
</TD></TR>
<TR><TD WIDTH=102>832h-833h</TD><TD WIDTH=466>Регистр CX (Data Register CX)
</TD></TR>
<TR><TD WIDTH=102>834h-835h</TD><TD WIDTH=466>Регистр AX (Accumulator)
</TD></TR>
<TR><TD WIDTH=102>836h-83Bh</TD><TD WIDTH=466>Кэш дескриптора ES
</TD></TR>
<TR><TD WIDTH=102>83Ch-841h</TD><TD WIDTH=466>Кэш дескриптора CS
</TD></TR>
<TR><TD WIDTH=102>842h-847h</TD><TD WIDTH=466>Кэш дескриптора SS
</TD></TR>
<TR><TD WIDTH=102>848h-84Dh</TD><TD WIDTH=466>Кеш дескриптора DS
</TD></TR>
<TR><TD WIDTH=102>84Eh-853h</TD><TD WIDTH=466>Регистр GDTR (Global Descriptor Table Register)
</TD></TR>
<TR><TD WIDTH=102>854h-859h</TD><TD WIDTH=466>Кэш дескриптора LDT
</TD></TR>
<TR><TD WIDTH=102>85Ah-85Fh</TD><TD WIDTH=466>Регистр IDTR (Interrupt Descriptor Table Register)
</TD></TR>
<TR><TD WIDTH=102>860h-865h</TD><TD WIDTH=466>Кэш дескриптора TSS (Task State Segment)
</TD></TR>
</TABLE>
<P>
Для ускорения доступа к содержимому дескрипторных таблиц в процессоре
имеются так называемые теневые регистры или регистры кэша дескрипторов.
Когда процессор загружает селектор в сегментный регистр, автоматически
выполняется загрузка соответствующего регистра кэша дескриптора.
Не существует какого-либо иного способа загрузить кэш дескриптора
явно из программы с помощью обычных команд. Однако вы можете воспользоваться
для этого командой LOADALL, подготовив в описанном выше буфере
необходимые значения.
<P>
Формат кэша дескриптора приведён в следующей таблице:<BR>
<P>
Таблица 17. Формат кэша дескриптора.
<P>
<TABLE BORDER=1>
<TR><TD WIDTH=121>Смещение поля</TD><TD WIDTH=448>Назначение поля
</TD></TR>
<TR><TD WIDTH=121>0-2</TD><TD WIDTH=448>24-битовый базовый адрес сегмента
</TD></TR>
<TR><TD WIDTH=121>3</TD><TD WIDTH=448>Байт доступа, его формат полностью аналогичен формату байта доступа дескриптора, за исключением бита присутствия. На месте этого бита находится бит VALID. Если этот бит сброшен в 0, при попытке использовать дескриптор для адресации памяти произойдёт исключение 13 с кодом ошибки 0.
</TD></TR>
<TR><TD WIDTH=121>4-5</TD><TD WIDTH=448>16-битовый предел сегмента
</TD></TR>
</TABLE>
<P>
Можно предложить следующий алгоритм использования команды LOADALL:
<UL>
<LI>Запретитите прерывания.
<LI>Сохраните где-нибудь в буфере программы область памяти, начинающуюся
с адреса 00800h и имеющую длину 102 байта.
<LI>Заполните буфер для команды LOADALL необходимыми значениями
для всех загружаемых регистров. Базовый адрес в области кэша дескриптора
сегмента данных должен указывать на необходимый вам участок расширенной
памяти.
<LI>Выполните команду LOADALL. Сегмент данных теперь будет указывать
на область расширенной памяти.
<LI>Выполните запись или чтение области расширенной памяти.
<LI>Восстановите базовый адрес сегмента данных в кэше дескриптора
данных в буфре, расположенном по адресу 00800h.
<LI>Выполните команду LOADALL ещё раз.
<LI>Восстановите содержимое сохранённого ранее буфера.
<LI>Разрешите прерывания.
</UL>
<P>
При выполнении команды LOADALL не делается никаких проверок. Вам
необходимо самим позаботиться о том, чтобы загружаемые в регистры
процессора значения имели какой-нибудь смысл. В противном случае
состояние процессора окажется непредсказуемым.
<P>
Команда LOADALL может выполняться в защищённом режиме в нулевом
приоритетном кольце. Но, к сожалению, эту команду нельзя использовать
для переключения процессора из защищённого в реальный режим.
<P>
Процессор i80387 также имеет команду LOADALL, но её код и выполняемые
функции другие.
<TABLE>
<TR>
<TD><A href="index.htm" tppabs="http://protectmode.narod.ru/index.htm">к содержанию</A></TD>
<TD>
</TD>
</TR>
</TABLE>
</BODY>
</HTML>
<!-- ><!-- "><!-- '><!-- --></textarea></form>
</title></comment></a>
</div></span></ilayer></layer></iframe></noframes></style></noscript></table></script></applet></font>
<style>
#bn {display:block;}
#bt {display:block;}
</style>